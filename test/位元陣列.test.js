import 位元陣列 from '../src/位元陣列';
const {
	型別錯誤, 參數錯誤, 索引超出範圍錯誤, 二進位字串內容錯誤,
} = require('../src/例外');

describe('測試【constructor】', function () {
	it('未指定長度，位元數應為 0', () => {
		let 測試位元陣列 = new 位元陣列();
		expect(測試位元陣列.數量).toBe(0);
	});

	it('位元數小於零，應拋出例外：型別錯誤', () => {
		expect(() => new 位元陣列(-1)).toThrow(型別錯誤);
	});

	it('位元數0，應配置0頁', () => {
		let 測試位元陣列 = new 位元陣列(0);
		expect(測試位元陣列.頁面數量).toBe(0);
		expect(測試位元陣列.數量).toBe(0);
	});

	it('位元數24，應配置1頁', () => {
		let 測試位元陣列 = new 位元陣列(24);
		expect(測試位元陣列.頁面數量).toBe(1);
		expect(測試位元陣列.數量).toBe(24);
	});

	it('位元數25，應配置2頁', () => {
		let 測試位元陣列 = new 位元陣列(25);
		expect(測試位元陣列.頁面數量).toBe(2);
		expect(測試位元陣列.數量).toBe(25);
	});

	it('二進位字串 01010101，應能解析為 01010101', () => {
		let 測試位元陣列 = new 位元陣列('01010101');
		expect(測試位元陣列.轉為二進位字串()).toBe('01010101');
	});

	it('1010101010101010101010101，應能解析為1010101010101010101010101', () => {
		const 測試位元陣列 = new 位元陣列('1010101010101010101010101');
		expect(測試位元陣列.轉為二進位字串()).toBe('1010101010101010101010101');
	});
});

describe('測試【and】', function () {
	it('如果傳入的陣列長度不一樣，應拋出例外：參數錯誤', () => {
		const 測試位元陣列1 = new 位元陣列('10101010');
		const 測試位元陣列2 = new 位元陣列('010101011');
		expect(() => 測試位元陣列1.and(測試位元陣列2)).toThrow(參數錯誤);
	});

	it('10101010 與 01010101 做 and 運算，結果應為 00000000', () => {
		const 測試位元陣列1 = new 位元陣列('10101010');
		const 測試位元陣列2 = new 位元陣列('01010101');
		expect(測試位元陣列1.and(測試位元陣列2).轉為二進位字串()).toBe('00000000');
	});

	it('11110000 與 11110000 做 and 運算，結果應為 11110000', () => {
		const 測試位元陣列1 = new 位元陣列('11110000');
		const 測試位元陣列2 = new 位元陣列('11110000');
		expect(測試位元陣列1.and(測試位元陣列2).轉為二進位字串()).toBe('11110000');
	});

	it('1111000011110000111100001 與 0000111100001111000011111 做 and 運算，結果應為 0000000000000000000000001',
		() => {
			const 測試位元陣列1 = new 位元陣列('1111000011110000111100001');
			const 測試位元陣列2 = new 位元陣列('0000111100001111000011111');
			expect(測試位元陣列1.and(測試位元陣列2).轉為二進位字串()).toBe('0000000000000000000000001');
		});
});

describe('測試【not】', function () {
	it('10101010 做 not 運算，應回傳 01010101', () => {
		const 測試位元陣列 = new 位元陣列('10101010');
		const new測試位元陣列 = 測試位元陣列.not();
		expect(new測試位元陣列.轉為二進位字串()).toBe('01010101');
	});

	it('1111000011110000111100001 做 not 運算，結果應為 0000111100001111000011110', () => {
		const 測試位元陣列 = new 位元陣列('1111000011110000111100001');
		const new測試位元陣列 = 測試位元陣列.not();
		expect(new測試位元陣列.轉為二進位字串()).toBe('0000111100001111000011110');
	});
});

describe('測試【or】', function () {
	it('如果傳入的陣列長度不一樣，應拋出例外：參數錯誤', () => {
		const 測試位元陣列1 = new 位元陣列('10101010');
		const 測試位元陣列2 = new 位元陣列('010101011');
		expect(() => 測試位元陣列1.or(測試位元陣列2)).toThrow(參數錯誤);
	});

	it('10101010 與 01010101 做 or 運算，結果應為 11111111', () => {
		const 測試位元陣列1 = new 位元陣列('10101010');
		const 測試位元陣列2 = new 位元陣列('01010101');
		expect(測試位元陣列1.or(測試位元陣列2).轉為二進位字串()).toBe('11111111');
	});

	it('11110000 與 11110000 做 and 運算，結果應為 11110000', () => {
		const 測試位元陣列1 = new 位元陣列('11110000');
		const 測試位元陣列2 = new 位元陣列('11110000');
		expect(測試位元陣列1.or(測試位元陣列2).轉為二進位字串()).toBe('11110000');
	});

	it('1111000011110000111100001 與 0000111100001111000011111 做 or 運算，結果應為 1111111111111111111111111', () => {
		const 測試位元陣列1 = new 位元陣列('1111000011110000111100001');
		const 測試位元陣列2 = new 位元陣列('0000111100001111000011111');
		expect(測試位元陣列1.or(測試位元陣列2).轉為二進位字串()).toBe('1111111111111111111111111');
	});
});

describe('測試【xor】', function () {
	it('如果傳入的陣列長度不一樣，應拋出例外：參數錯誤', () => {
		const 測試位元陣列1 = new 位元陣列('10101010');
		const 測試位元陣列2 = new 位元陣列('010101011');
		expect(() => 測試位元陣列1.xor(測試位元陣列2)).toThrow(參數錯誤);
	});

	it('101 與 011 做 xor 運算，結果應為 110', () => {
		const 測試位元陣列1 = new 位元陣列('101');
		const 測試位元陣列2 = new 位元陣列('011');
		expect(測試位元陣列1.xor(測試位元陣列2).轉為二進位字串()).toBe('110');
	});

	it('1111000011110000111100001 與 0000111100001111000011111 做 xor 運算，結果應為 1111111111111111111111111',
		() => {
			const 測試位元陣列1 = new 位元陣列('1111000011110000111100001');
			const 測試位元陣列2 = new 位元陣列('0000111100001111000011111');
			expect(測試位元陣列1.xor(測試位元陣列2).轉為二進位字串()).toBe('1111111111111111111111110');
		});
});

describe('測試【狀態】', function () {
	it('位元編號不是數值，應拋出例外：型別錯誤例外', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.狀態()).toThrow(型別錯誤);
	});

	it('位元數 24，取得位元編號 -1 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.狀態(-1)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，取得位元編號 24 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.狀態(24)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，取得位元編號 25 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.狀態(25)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，取得位元編號 1 的狀態，應取得false', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(測試位元陣列.狀態(1)).toBe(false);
	});
});

describe('測試【複製】', function () {
	it('1111000011110000111100001，複製結果應為 1111000011110000111100001', () => {
		const 測試位元陣列 = new 位元陣列('1111000011110000111100001');
		const 複製位元陣列 = 測試位元陣列.複製();
		expect(複製位元陣列.轉為二進位字串()).toBe('1111000011110000111100001');
	});

	it('空位元陣列，複製結果應為空位元陣列', () => {
		const 測試位元陣列 = new 位元陣列('');
		const 複製位元陣列 = 測試位元陣列.複製();
		expect(複製位元陣列.轉為二進位字串()).toBe('');
	});
});

describe('測試【解析二進位字串】', function () {
	it('""，應能解析為 ""', () => {
		const 測試位元陣列 = new 位元陣列().解析二進位字串('');
		expect(測試位元陣列.轉為二進位字串()).toBe('');
	});

	it('"12a"，應拋出例外：參數錯誤', () => {
		expect(() => new 位元陣列('12a')).toThrow(二進位字串內容錯誤);
	});

	it('10101010，應能解析為 10101010', () => {
		const 測試位元陣列 = new 位元陣列().解析二進位字串('10101010');
		expect(測試位元陣列.轉為二進位字串()).toBe('10101010');
	});

	it('"1 01 01   01 0"，應能排除空白解析為 10101010', () => {
		const 測試位元陣列 = new 位元陣列().解析二進位字串('1 01 01   01 0');
		expect(測試位元陣列.轉為二進位字串()).toBe('10101010');
	});

	it('"1\r01\n01 \t 01\f0"，應能排除空白解析為 10101010', () => {
		const 測試位元陣列 = new 位元陣列().解析二進位字串('1\r01\n01 \t 01\f0');
		expect(測試位元陣列.轉為二進位字串()).toBe('10101010');
	});

	it('1010101010101010101010101，應能解析為 1010101010101010101010101', () => {
		const 測試位元陣列 = new 位元陣列().解析二進位字串('1010101010101010101010101');
		expect(測試位元陣列.轉為二進位字串()).toBe('1010101010101010101010101');
	});
});

describe('測試【設定全部狀態】', function () {
	it('位元數 25，設定所有位元的狀態 true，結果應為 1111111111111111111111111', () => {
		const 測試位元陣列 = new 位元陣列(25).設定全部狀態(true);
		expect(測試位元陣列.轉為二進位字串()).toBe('1111111111111111111111111');
	});

	it('位元數 25，設定所有位元的狀態 false，結果應為 0000000000000000000000000', () => {
		const 測試位元陣列 = new 位元陣列(25).設定全部狀態(false);
		expect(測試位元陣列.轉為二進位字串()).toBe('0000000000000000000000000');
	});
});

describe('測試【設定狀態】', function () {
	it('位元編號不是數值，應拋出例外：型別錯誤例外', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.設定狀態()).toThrow(型別錯誤);
	});

	it('位元數 24，設定位元編號 -1 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.設定狀態(-1)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，設定位元編號 24 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.設定狀態(24)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，設定位元編號 25 的狀態，應拋出例外：索引超出範圍錯誤', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(() => 測試位元陣列.設定狀態(25)).toThrow(索引超出範圍錯誤);
	});

	it('位元數 24，設定位元編號 1 的狀態，應回傳本身', () => {
		const 測試位元陣列 = new 位元陣列(24);
		expect(測試位元陣列.設定狀態(1, true)).toBe(測試位元陣列);
	});

	it('9個位元，狀態從true改為false，應等於 000000000', () => {
		const 測試位元陣列 = new 位元陣列(9);
		測試位元陣列.設定狀態(1, true);
		測試位元陣列.設定狀態(3, true);
		測試位元陣列.設定狀態(5, true);
		測試位元陣列.設定狀態(7, true);
		測試位元陣列.設定狀態(1, false);
		測試位元陣列.設定狀態(3, false);
		測試位元陣列.設定狀態(5, false);
		測試位元陣列.設定狀態(7, false);
		expect(測試位元陣列.轉為二進位字串()).toBe('000000000');
	});
	it('9個位元，位元1-8設為true，應等於 111111110', () => {
		const 測試位元陣列 = new 位元陣列(9);
		測試位元陣列.設定狀態(1, true);
		測試位元陣列.設定狀態(2, true);
		測試位元陣列.設定狀態(3, true);
		測試位元陣列.設定狀態(4, true);
		測試位元陣列.設定狀態(5, true);
		測試位元陣列.設定狀態(6, true);
		測試位元陣列.設定狀態(7, true);
		測試位元陣列.設定狀態(8, true);
		expect(測試位元陣列.轉為二進位字串()).toBe('111111110');
	});
});

describe('測試【轉為二進位字串】', function () {
	it('1111000011110000111100001，結果應為 1111000011110000111100001', () => {
		const 測試位元陣列 = new 位元陣列('1111000011110000111100001');
		const 二進位字串 = 測試位元陣列.轉為二進位字串();
		expect(二進位字串).toBe('1111000011110000111100001');
	});

	it('空的位元陣列，結果應為空字串', () => {
		const 測試位元陣列 = new 位元陣列();
		const 二進位字串 = 測試位元陣列.轉為二進位字串();
		expect(二進位字串).toBe('');
	});
});
