# 位元陣列

[toc]

## 類別概述

`位元陣列` 是一個用於位元操作的數據結構，支援高效的二進位管理與操作。本類別提供了靈活的初始化方式（字串或數值），並支援位元運算（`AND`、`OR`、`XOR`）和位元管理操作（設置、讀取、反轉等）。主要用途包括管理和處理位元級別的數據，適合用於壓縮存儲及高效操作。

###  類別圖

以下為 `位元陣列` 類別的類別圖：

```mermaid
classDiagram
    class 位元陣列 {
        #一頁可紀錄的位元數
        #數量
        #頁面
        #四位元組
        +and(另一個陣列): 位元陣列
        +not(): 位元陣列
        +or(另一個陣列): 位元陣列
        +xor(另一個陣列): 位元陣列
        +狀態(位元編號): boolean
        +複製(): 位元陣列
        +解析二進位字串(字串): 位元陣列
        +設定全部狀態(狀態): 位元陣列
        +設定狀態(位元編號, 狀態): 位元陣列
        +轉為二進位字串(): string
        #執行邏輯運算(另一個向量, 運算符): 位元陣列
        #確保二進位字串只有0和1的字元(字串)
        #確定位元編號在範圍內(位元編號)
        #計算需要的頁面數量(位元數量): number
        #設定位元數量(新數量)
        #驗證(條件, 錯誤類別, 錯誤訊息)
        #取得頁面編號(位元編號): number
    }
```

------

## Public Methods 說明

### `and` 方法

#### 功能概述

`and` 方法用於執行兩個位元陣列間的邏輯 AND（且）運算。該方法會逐位元地比較兩個位元陣列中對應位置上的位元值，若兩位元皆為 `1`，結果位元為 `1`，否則結果位元為 `0`。結果將以一個新的位元陣列回傳。

#### 技術結構

1. 確認傳入的 `另一個陣列` 與當前位元陣列的位元數量相同，否則拋出錯誤。
2. 使用逐位元邏輯 AND 運算符 (`&`)，對整個位元陣列進行運算。
3. 回傳一個新的位元陣列，包含運算結果。

------

#### 參數規格與回傳

##### 參數規格

| 參數名稱     | 類型       | 描述                                                        | 是否必要 |
| ------------ | ---------- | ----------------------------------------------------------- | -------- |
| `另一個陣列` | `位元陣列` | 用於進行 AND 運算的另一個位元陣列，需與當前陣列位元數量相同 | 是       |

##### 回傳值

| 回傳值     | 類型       | 描述                                            |
| ---------- | ---------- | ----------------------------------------------- |
| `結果陣列` | `位元陣列` | 包含兩個位元陣列進行 AND 運算後結果的新位元陣列 |

------

#### 循序圖

以下是 `and` 方法的執行流程圖，使用 **Mermaid.js** 表達：

```mermaid
sequenceDiagram
    autoNumber
    participant User as 使用者
    participant BitArray1 as 位元陣列 1
    participant BitArray2 as 位元陣列 2
    participant NewBitArray as 新位元陣列
    User->>BitArray1: 呼叫 and(另一個陣列)
    BitArray1->>BitArray2: 驗證位元數量是否一致
    BitArray2-->>BitArray1: 回傳驗證結果
    BitArray1->>NewBitArray: 逐位元執行 AND 運算
    NewBitArray-->>BitArray1: 回傳結果
    BitArray1-->>User: 返回新的位元陣列
```

------

#### 程式邏輯

1. 驗證傳入的 

   ```
   另一個陣列
   ```

   - 檢查是否與當前位元陣列擁有相同的位元數量。
   - 若位元數量不符，則拋出 `參數錯誤`。

2. 定義運算函數：

   - 使用內部 `#執行邏輯運算` 方法，傳入運算符 `'and'` 與 `另一個陣列`。

3. 運算邏輯：

   - 逐頁面對應執行 AND 運算，即對每個頁面的 32 位元數據進行逐位元處理。
   - 使用邏輯運算符 `&` 計算結果。

4. 結果回傳：

   - 此運算的結果儲存於新的位元陣列中，並作為回傳值。

------

### `not`

#### 功能概述

`not`用於對當前位元陣列的每個位元進行位元反轉（NOT 運算），即將所有的 `0` 反轉為 `1`，而 `1` 反轉為 `0`。此方法會返回一個新的位元陣列作為運算結果，而不會改變原始位元陣列的內容。

------

#### 技術結構

此方法的工作流程如下：

1. 創建一個新的位元陣列，其大小與當前位元陣列相同。
2. 對每個頁面的數值進行位元反轉運算（使用 JavaScript 的位元運算符 `~`）。
3. 將反轉後的頁面數據存入新位元陣列。
4. 返回新的位元陣列，代表反轉結果。

------

#### 參數規格與回傳

**參數：**

此方法不需要參數。

| 參數名稱 | 類型 | 描述           | 必要性 |
| -------- | ---- | -------------- | ------ |
| 無       | -    | 無參數需要傳遞 | -      |

**回傳值：**

| 回傳值     | 類型       | 描述                                                         |
| ---------- | ---------- | ------------------------------------------------------------ |
| 新位元陣列 | `位元陣列` | 包含當前位元陣列中每個位元反轉後的結果，這是一個全新的位元陣列實例。 |

------

#### 循序圖

以下為 `not`執行的邏輯流程循序圖（使用 mermaid.js 格式）：

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者
    participant 位元陣列
    note over 位元陣列: 初始化新的位元陣列 (`回傳結果`)
    使用者 ->> 位元陣列: 呼叫 `not()`
    位元陣列 ->> 位元陣列: 遍歷內部頁面陣列
    loop 每個位元頁面
        位元陣列 ->> 位元陣列: 執行位元反轉 (~)
        位元陣列 ->> 回傳結果: 保存處理後的頁面數據
    end
    位元陣列 ->> 使用者: 回傳新的位元陣列
```

------

#### 程式邏輯

1. **創建新位元陣列：**
      依據當前位元陣列的大小，初始化一個新的位元陣列物件，用以存放反轉後的結果。
2. **遍歷頁面：**
      遍歷位元陣列的每個頁面(`#頁面`)。
3. **執行反轉運算：**
      使用位元運算符 `~` 對頁面內容逐位元進行反轉操作。
4. **保存反轉結果：**
      將反轉後的結果存入新位元陣列的頁面結構中。
5. **返回新陣列：**
      返回包含反轉後結果的位元陣列。

------

### `or`

#### 功能概述

`or`用於對兩個位元陣列進行逐位元的 OR（或）運算。此操作的結果將會是根據每個位元的邏輯 OR 運算後產生的新位元陣列。要求傳入的位元陣列的長度必須與當前位元陣列相同，否則會拋出錯誤。

#### 技術結構

- 對於每一頁的位元數據，使用位元運算符 `|` 執行 OR 運算。
- 結果保存在新的位元陣列中，該位元陣列的結構與原始陣列相同。
- 方法內部依賴進行頁數的操作和位元數據的逐一處理。

#### 參數規格與回傳

| **參數名稱** | **類型**   | **描述**                                                     | **必要性** |
| ------------ | ---------- | ------------------------------------------------------------ | ---------- |
| `另一個陣列` | `位元陣列` | 欲進行 OR 操作的位元陣列，<br />其位元數量必須與當前位元陣列相同。 | 必要       |

###### 回傳值

| **回傳值** | **類型**   | **描述**                       |
| ---------- | ---------- | ------------------------------ |
| `or 結果`  | `位元陣列` | 包含 OR 運算結果的新位元陣列。 |

#### 循序圖

以下示範 `or`的執行流程：

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者
    participant 位元陣列1
    participant 位元陣列2
    participant 新位元陣列
    使用者->>位元陣列1: 呼叫 or 方法，傳入 位元陣列2
    位元陣列1->>位元陣列2: 驗證位元數量是否相同
    alt 位元數不同
        位元陣列1->>使用者: 拋出錯誤「參數錯誤」
    else 位元數相同
        位元陣列1->>新位元陣列: 初始化新陣列
        loop 遍歷每頁
            位元陣列1->>位元陣列2: 執行每頁位元的 OR 運算
            新位元陣列->>新位元陣列: 儲存 OR 運算結果
        end
        位元陣列1->>使用者: 返回新位元陣列
    end
```

#### 程式邏輯

1. 接受一個參數 `另一個陣列`，檢查其是否為有效的位元陣列，且確認其位元數量與當前位元陣列相同。
2. 若位元數量不同，拋出 `參數錯誤`。
3. 初始化一個與當前位元陣列長度相同的新 `位元陣列` 以儲存運算結果。
4. 遍歷所有頁數，對每一頁的位元數據執行逐位元的 OR 運算：
   - 使用位元運算符 `|` 進行操作。
   - 將結果寫入新的位元陣列中對應的頁面。
5. 回傳包含運算結果的新位元陣列。

------

### `xor`

#### 功能概述

`xor`執行當前位元陣列與另一個位元陣列之間的 XOR 運算。對每個位元進行邏輯 XOR 操作，並將結果存儲於一個新的位元陣列中作為結果返回。此方法可用於進行位元元模式的比較和差異分析操作。

#### 技術結構

1. 接收一個與當前位元陣列長度相等的另一個位元陣列作為操作對象。
2. 驗證兩個位元陣列的長度是否一致，若不一致則拋出參數錯誤。
3. 運用 XOR 運算符（`^`），逐頁對兩個位元陣列進行運算。
4. 輸出一個新的位元陣列實例，包含運算結果的位元數據。

#### 參數規格與回傳

| **參數名稱** | **類型**   | **描述**                                          | **必要性** |
| ------------ | ---------- | ------------------------------------------------- | ---------- |
| 另一個陣列   | `位元陣列` | 用於進行 XOR 運算的另一個位元陣列（需長度相等）。 | 必須       |

回傳值：

| **回傳值** | **類型**   | **描述**                          |
| ---------- | ---------- | --------------------------------- |
| 運算結果   | `位元陣列` | 包含 XOR 運算結果的位元陣列實例。 |

#### 循序圖

以下是 `xor`的操作流程，使用 Mermaid.js 表示：

```mermaid
sequenceDiagram
  autoNumber
  participant User as 使用者
  participant CurrentArray as 當前位元陣列
  participant AnotherArray as 另一個位元陣列
  participant ResultArray as 新位元陣列 (結果)

  User->>CurrentArray: 調用 xor(另一個陣列)
  CurrentArray->>CurrentArray: 驗證位元數量是否相等
  alt 位元數量不相等
    CurrentArray->>User: 拋出參數錯誤
  else 位元數量相等
    CurrentArray->>ResultArray: 初始化新位元陣列
    loop 每一頁
      CurrentArray->>ResultArray: 執行 XOR 運算
    end
    CurrentArray->>User: 返回結果位元陣列
  end
```

#### 程式邏輯

1. **參數驗證**：檢查傳入的位元陣列是否與當前位元陣列具有相同的位元數量，若不同則拋出參數錯誤。

2. 運算操作

   ：基於另一次數組，逐頁（根據分頁大小）進行位元的 XOR（異或）運算：

   - 計算每頁的資料，對應位元與運算結果儲存在新位元陣列內。
   - 每一整頁位元數據使用 JavaScript 的二元 XOR 運算符（`^`）。

3. **結果返回**：將包含 XOR 運算結果的新位元陣列返回給使用者。

------

### `狀態` 

#### 功能概述

`狀態`用於查詢位於指定位元位置的狀態值（布林值）。通過傳入位元編號，方法會返回該編號對應位置的位元是否為 1。若值為 1，則返回 `true`，否則返回 `false`。

#### 技術結構

該方法依賴內部的 **分頁存儲結構**，通過計算位元所在的頁面及在頁面中的位置，執行有效查詢並返回結果。同時，該方法會進行必要的參數驗證，確保位元編號合法，且避免索引錯誤。

------

#### 參數規格與回傳

##### 參數

| **參數名稱** | **類型** | **描述**                                                     | **必要性** |
| ------------ | -------- | ------------------------------------------------------------ | ---------- |
| 位元編號     | `number` | 欲查詢的位元編號必須為非負整數，且小於當前位元陣列的總位元數量。 | 是         |

##### 回傳值

| **回傳值** | **類型**  | **描述**                                                  |
| ---------- | --------- | --------------------------------------------------------- |
| 位元狀態   | `boolean` | 如果指定位置的位元為 `1`，返回 `true`，否則返回 `false`。 |

------

#### 循序圖

以下循序圖表示 `狀態`的工作流程：

```mermaid
sequenceDiagram
    autoNumber
    participant Client as 調用方
    participant Method as 狀態(位元編號)
    participant Internal as 位元陣列內部
    Client->>Method: 傳入位元編號
    Method->>Internal: 確保位元編號在範圍內
    Internal-->>Method: 驗證通過
    Method->>Internal: 計算頁面索引、位元元元遮罩
    Internal-->>Method: 返回計算結構
    Method->>Internal: 查詢該頁面位元狀態
    Internal-->>Method: 返回查詢結果
    Method-->>Client: 返回布爾值表明位元狀態
```

------

#### 程式邏輯

1. **參數驗證**：
   - 使用內部私有方法 `#確定位元編號在範圍內` 驗證提供的位元編號是否為合法值。
   - 如果位元編號非法，則拋出相應的錯誤（例如：`型別錯誤` 或 `索引超出範圍錯誤`）。
2. **頁面計算**：
   - 根據提供的位元編號計算該位元在內部頁面數據結構中的分頁位置：     
     - 頁面索引 = `Math.floor(位元編號 / 一頁可紀錄位元數)`。
     - 位元遮罩 = `1 << (位元編號 % 一頁可紀錄位元數)`。
3. **位元查詢**：
   - 通過位元遮罩和位元在分頁中的偏移量，獲取該位置的位元狀態（0 或 1）。
4. **返回值**：
   - 如果位元狀態為 `1`，返回 `true`；
   - 如果位元狀態為 `0`，返回 `false`。

這種設計確保了查詢操作的效率，同時借助分頁結構減少了內存使用，提高了執行性能。

------

### `複製`

#### 功能概述

`複製`用於建立並返回當前 **位元陣列**（`位元陣列` 類的例項）的完整複本。該方法實現位元陣列的深層拷貝，確保複製的陣列獨立於原始陣列，且不會影響彼此的後續操作。

------

#### 技術結構

`複製`內部使用 JavaScript 的陣列拷貝功能進行高效的分頁資料複製，並維持頁面記錄的完整性與位元運算結果不變。本方法不修改原始的 `位元陣列`，只生成一個全新的實例。

------

#### 參數規格與回傳

| 參數名稱 | 類型 | 描述                       | 必要性 |
| -------- | ---- | -------------------------- | ------ |
| 無       | 無   | 本方法不接受任何輸入參數。 | N/A    |

| 回傳值                 | 類型       | 描述                                       |
| ---------------------- | ---------- | ------------------------------------------ |
| 新位元陣列（複製參數） | `位元陣列` | 內容與原來的位元陣列相同的新位元陣列實例。 |

------

#### 循序圖

以下循序圖展示了方法內部執行的主要處理邏輯：

```mermaid
sequenceDiagram
    autoNumber
    participant Caller as 呼叫者
    actor 複製 as 複製方法
    participant 位元陣列 as 位元陣列實例
    Caller ->> 複製: 呼叫複製方法
    複製 ->> 位元陣列: 建立新位元陣列物件
    複製 ->> 位元陣列: 拷貝原始分頁資料 (slice)
    位元陣列 -->> 複製: 完成複製
    複製 -->> Caller: 傳回新位元陣列
```

------

#### 程式邏輯

1. **初始化新位元陣列**
      使用當前 `位元陣列` 的位元數量（`數量`屬性），建立具有相同長度的新 `位元陣列` 實例。
2. **拷貝分頁資料**
      透過陣列的 `slice`，將目前儲存位元的分頁（`#頁面`屬性）資料完整拷貝，避免共用同一記憶體位置。
3. **返回複本**
      返回新建的位元陣列實例。新位元陣列的內容與原始陣列一致，但兩者相互獨立，不會有任何改動影響對方。 

------

### `解析二進位字串`

#### 功能概述

`解析二進位字串` 是 `位元陣列` 類別中的一個方法，用於將一個包含二進位表示的字串解析為位元陣列的內部數據結構。此方法支援移除字串中的空白字元，並驗證字串完整性（僅允許 `0` 和 `1`）。解析完成後，該方法會將結果存儲於位元陣列的頁面中，並返回當前的 `位元陣列`。

#### 技術結構

1. 輸入格式處理

   - 移除輸入字串中的所有空白（包括空格、換行符等）。
   - 驗證字串是否僅包含有效的二進位字元（`0` 和 `1`）。
   
2. 位元儲存結構

   - 將解析後的每組位元按照分頁大小存儲至陣列的各個頁面中。
   - 每頁中的位元數由內部屬性 `#一頁可紀錄的位元數` 決定，如 24 位元。
   
3. 流程控制

   - 逐頁處理二進位字串的分段，轉換為數字並存儲在頁面陣列中。

#### 參數規格與回傳

| 參數名稱     | 類型     | 描述                                                         | 必要性 |
| ------------ | -------- | ------------------------------------------------------------ | ------ |
| `二進位字串` | `string` | 欲解析的二進位字串，可包含空白字元，<br />僅允許 `0` 和 `1` 為有效輸入字元。 | 必填   |

**回傳值**

- 類型：`位元陣列`
- 描述：返回包含解析後結果的當前 `位元陣列` 實例，以支援鏈式調用。

**拋出例外**

- **Exception**: 當輸入的字串包含無效字元時（非 `0` 或 `1`），拋出錯誤。

#### 循序圖

以下為 `解析二進位字串` 的處理流程圖（使用 `mermaid.js` 格式）：

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者
    participant 位元陣列
    participant 字串工具 as 字串工具
    使用者->>位元陣列: 傳入二進位字串
    位元陣列->>字串工具: 移除空白字元
    字串工具-->>位元陣列: 回傳清理後的字串
    位元陣列->>位元陣列: 檢查字串是否合法 (僅含 0 和 1)
    alt 非法字元
        位元陣列-->>使用者: 拋出錯誤「非法字元」
    end
    位元陣列->>位元陣列: 計算需要的頁面數
    loop 每個頁面
        位元陣列->>位元陣列: 取對應的字串分段
        位元陣列->>位元陣列: 轉換為整數並存到頁面
    end
    位元陣列->>使用者: 返回已解析的位元陣列
```

#### 程式邏輯

1. 移除字串中的所有空白字元：
   - 使用 `字串工具.移除空白字元`清理字串輸入。
2. 驗證字串有效性：
   - 檢查字串中是否僅包含 `0` 和 `1`，如果包含其他字元則拋出錯誤。
3. 初始設置：
   - 針對輸入字串的長度，計算所需的總位元數，並設置內部位元數量。
   - 資料分頁：根據內部屬性 `#一頁可紀錄的位元數`，將字串按分頁大小切分並逐頁存儲。
4. 返回當前位元陣列：
   - 支援鏈式調用，允許進一步操作。

------

### `設定全部狀態`

#### 功能概述

`設定全部狀態` 是 `位元陣列` 中用來將位元陣列的所有位元進行快速統一設置的功能。
 方法接受一個布林值參數，將所有位元設為 `1`（若參數為 `true`）或 `0`（若參數為 `false`）。該操作會影響整個位元陣列中的所有位元，並可支援鏈式調用。

#### 技術結構

1. 該方法基於內部的 `#頁面` 陣列進行操作，將每個頁面的數據以統一值進行填充。
2. 根據傳入的布林值確定填充值：  
   - 若為 `true`，則填充最大可表示的值（對應所有位元為 1，如 `0xFFFFFF`）。  
   - 若為 `false`，則填充 0（所有位元為 0，如 `0x000000`）。  
3. 填充操作透過內建的陣列 `.fill()`高效完成。

------

#### 參數規格與回傳

| 參數名稱 | 類型    | 描述                             | 必要性 |
| -------- | ------- | -------------------------------- | ------ |
| 狀態     | boolean | 設定所有位元的目標狀態，為布林值 | 必填   |

**回傳值**

- 此方法返回當前的位元陣列對象（`位元陣列`），以支援鏈式調用。

------

#### 循序圖

以下是 `設定全部狀態`的執行流程循序圖：

```mermaid
sequenceDiagram
    autoNumber
    participant User
    participant 位元陣列
    User->>位元陣列: 呼叫 設定全部狀態(狀態: boolean)
    位元陣列->>位元陣列: 判斷狀態是否為 true 或 false
    位元陣列->>位元陣列: 根據狀態設置 填充值（0xFFFFFF 或 0x000000）
    位元陣列->>位元陣列: 使用 #頁面.fill(填充值) 完全覆蓋頁面內容
    位元陣列->>User: 返回當前位元陣列（支援鏈式調用）
```

------

#### 程式邏輯

1. 接收一個布林值參數 `狀態`。

2. 判斷 

   ```
   狀態
   ```

    值：

   - 若為 `true`，將 `填充值` 設置為 `0xFFFFFF`（二進位 `111111`，表示所有位元設為 1）。
   - 若為 `false`，將 `填充值` 設置為 `0x000000`（二進位 `000000`，表示所有位元設為 0）。

3. 透過內部的 `#頁面` 陣列中的 `.fill()`，將陣列所有單元修改為對應的 `填充值`。

4. 返回當前的位元陣列，以支援方法鏈式呼叫。  

該方法的設計確保了高效操作整個位元陣列，無需逐一設置每個位元狀態，也因此在處理大規模位元數據時尤為高效。

------

### `設定狀態`

#### 功能概述

`設定狀態`允許使用者指定位於位元陣列中的某個位元的狀態（0 或 1）。此功能適用於需要精確控制單一位元運作的場景。例如，啟用標記、保存狀態或執行位元層級運算。

------

#### 技術結構

此方法利用內部私有屬性記錄位元數據，並以位元遮罩進行按位操作：

- **寫入 1（啟用）**: 運用位元遮罩與 `OR` 運算符 (`|`)。
- **寫入 0（停用）**: 使用遮罩的反向與 `AND` 運算符 (`&`)。

內部邏輯確保：

1. 位元編號的有效性（範圍檢查）。
2. 根據位元編號計算位於內部頁面的對應位置。

------

#### 參數規格與回傳

| **參數名稱** | **類型**  | **描述**                                        | **必要性** |
| ------------ | --------- | ----------------------------------------------- | ---------- |
| `位元編號`   | `number`  | 欲設定的位元元元位置（索引）。                      | 必須       |
| `狀態`       | `boolean` | 指定位元的目標狀態，`true` 為 1；`false` 為 0。 | 必須       |

**回傳值**

- 類型: `位元陣列`
- 描述: 回傳的是自身實例，以支援鏈式調用。

**可能拋出的例外:**

- **型別錯誤** (`型別錯誤`): 如果 `位元編號` 不是數字，則會拋出此錯誤。
- **索引超出範圍錯誤** (`索引超出範圍錯誤`): 如果 `位元編號` 超出合法範圍（即大於現有位元），會拋此例外。

------

#### 循序圖

以下利用 mermaid.js 描繪 `設定狀態`的執行流程：

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者 as 使用者
    participant 位元陣列 as 位元陣列
    participant 私有方法 as 私有方法
    
    使用者->>位元陣列: 呼叫 設定狀態(位元編號, 狀態)
    位元陣列->>私有方法: 驗證位元編號有效性（#確定位元編號在範圍內）
    私有方法-->>位元陣列: 返回（成功或拋出例外）
    位元陣列->>位元陣列: 計算 分頁編號 與 位元遮罩
    alt 狀態為 true
        位元陣列->>位元陣列: 使用 OR (`|`) 運算更新位元
    else 狀態為 false
        位元陣列->>位元陣列: 使用 AND (`&`) 運算清除位元
    end
    位元陣列-->>使用者: 返回當前位元陣列
```

------

#### 程式邏輯

1. 驗證目標位元編號是否合法 (內部方法 `#確定位元編號在範圍內`)：
   - 驗證是否為數值。
   - 驗證是否介於 `0` 和 `位元陣列.數量 - 1` 之間。
2. 計算位元的位置資訊：
   - 分頁編號：`位元編號` 所屬的頁面，基於 `Math.floor(位元編號 / 每頁位元數)` 計算。
   - 二進位遮罩：用於特定位元位置的操作，計算公式為 `1 << (位元編號 % 每頁位元數)`。
3. 更新位元狀態：
   - 若狀態為 `true`（設為 1）：透過運算 `頁面[分頁編號] |= 位元遮罩`。
   - 若狀態為 `false`（設為 0）：進行清除操作，即 `頁面[分頁編號] &= ~位元遮罩`。
4. 返回修改後的位元陣列物件（支援鏈式調用）。

------

#### 範常式式碼

以下是利用 `設定狀態`的範例：

```javascript
// 建立一個具有 8 個位元的位元陣列
const 位元陣列 = new 位元陣列(8);

// 設置第 2 位為 1
位元陣列.設定狀態(2, true);
console.log(位元陣列.轉為二進位字串()); // 輸出: "00100000"

// 設置第 2 位為 0
位元陣列.設定狀態(2, false);
console.log(位元陣列.轉為二進位字串()); // 輸出: "00000000"
```

------


### `轉為二進位字串`

#### **功能概述**

`轉為二進位字串`將位元陣列中的內容轉換為一個以 `0` 和 `1` 表示的二進位字串。這個方法可以讓用戶輕鬆地獲取位元陣列中所有位元的完整狀態，作為字串進一步使用，例如儲存文本或傳輸數據。

------

#### **技術結構**

1. **位元運算與分段處理**：
   - 每一頁的存儲形式採用 24 位元元記錄模式。
   - 使用位元運算將數字拆分為每 4 位一段，對應到二進位。
   - 透過靜態屬性 `四位元組`（存放 16 種可能的二進位字串：從 `0000` 到 `1111`），可以高效進行進位數據的轉換處理。
2. **數字到字串的組合與對齊**：
   - 針對每頁的位元內容，使用遮罩與位移操作，依次拆分出對應的 4 位組合。
   - 合併所有頁面內容後，去除多餘填充的字元，確保輸出僅對應有效位元數量。
3. **倒序排列**：
   - 所得到的二進位字串以 **逆向模式** 進行處理，然後再反轉，保證生成的字串順序如同從最左側位到最右側位的排列。

------

#### **參數規格與回傳**

**參數**

- 無。

**回傳**

- **型別**: `string`
- **含義**: 一個包含所有位元狀態的「01」格式字串，長度等於位元陣列中實際的位元數量。

------

#### **程式邏輯**

1. **取得每頁的位元數據**：
   - 根據設置的每頁紀錄位元數來拆分 `<頁面>` 數據，並計算對應的 **四位元組數量**（位元數/4）。
2. **數據轉換**：
   - 循環遍歷每一頁，對該頁的數據進行位元運算，將其根據「每 4 位元一組」的模式分割成段，並對應到固定字串表 `四位元組`。
3. **拼接與裁剪**：
   - 從低位元元到高位收集所有的二進位段，組合為完整字串（注意 `flatMap` 用於扁平化處理多維陣列）。
   - 使用 `reverse` 確保結果按照正確的高位到低位元元排列順序。
   - 最後使用 `slice` 擷取字串的有效部分，確保刪除多餘的填充數據。

------

#### **循序圖**

```mermaid
sequenceDiagram
    autoNumber
    participant User as 調用API
    participant 位元陣列 as 位元陣列對象
    participant 儲存器 as 頁面數據

    User ->> 位元陣列: 呼叫 轉為二進位字串()
    位元陣列 ->> 儲存器: 獲取頁面數據 (#頁面)
    activate 儲存器
    loop 遍歷每個頁面
        位元陣列 ->> 儲存器: 擷取一部分二進位數據 (按 4 位分段)
        儲存器 -->> 位元陣列: 返回 4 位元組對應字串
    end
    deactivate 儲存器
    位元陣列 ->> 位元陣列: 拼接所有字串
    位元陣列 ->> 位元陣列: 裁剪有效部分內容(基於 #數量)
    位元陣列 -->> User: 返回結果字串 (01 串)
```

------

#### **程式邏轉為二進位字串輯重點**

1. 初始化一個結果陣列 `結果`，作為臨時存儲所有提取位元元元組的集合。
2. 遍歷位元陣列的所有 `#頁面`，基於「四位元組」的轉換邏輯進行分組轉化。
3. 經由 `reverse()` 調整順序後，將陣列轉為字串後返回。

以下是該方法的邏輯示意：

```javascript
轉為二進位字串() {
    const 四位元組的數量 = this.#一頁可紀錄的位元數 / 4; // 每 4 位數據
    const 結果 = this.#頁面.flatMap(x => 
        Array.from({ length: 四位元組的數量 }, (_, i) => 
            位元陣列.四位元組[(x >> (i * 4)) & 0x0000000F]
        )
    );
    return 結果.reverse().join('').slice(-this.#數量);
}
```

------

## Private Methods 說明

### `取得頁面編號`

#### 功能概述

`取得頁面編號` 是一個私有方法，用於計算給定位元編號所在的頁面編號。由於位元元陣列是按照分頁方式管理位元元數據，此方法根據當前每頁可紀錄的位元數 (`#一頁可紀錄的位元數`) 計算指定位元編號的對應頁面編號，頁面從 `0` 開始。

#### 技術結構

該方法使用數學公式 `Math.floor(位元編號 / 每頁可紀錄位元數)` 來計算給定位元編號所屬的頁面編號。頁面編號用於定位位元在內部陣列的存儲位置。

- **方法私有**：僅在內部調用，確保外部無法直接使用此功能。
- **無錯誤檢查**：假設傳入的位元編號已被驗證為合法值。

#### 參數規格與回傳

| 參數名稱   | 類型     | 描述                           | 必要性 |
| ---------- | -------- | ------------------------------ | ------ |
| `位元編號` | `number` | 欲查詢的位元編號，需為非負整數 | 必須   |

**回傳值**

| 回傳值   | 類型     | 描述                                      |
| -------- | -------- | ----------------------------------------- |
| 頁面編號 | `number` | 該位元編號所屬的頁面編號，從 `0` 開始計算 |

#### 循序圖

```mermaid
sequenceDiagram
    autoNumber
    participant 呼叫端
    participant 取得頁面編號
    呼叫端->>取得頁面編號: 傳入位元編號
    取得頁面編號-->>呼叫端: 計算並返回頁面編號
```

#### 程式邏輯

1. 接收一個非負整數的位元編號作為輸入參數。

2. 使用公式 

   ```
   Math.floor(位元編號 / #一頁可紀錄的位元數)
   ```

    計算該位元元的頁面索引。

   - `位元編號`：欲操作的位元在整個位元陣列中的唯一標識。
   - `#一頁可紀錄的位元數`：每頁可以存放的最大位元數，為類別的一個私有屬性。

3. 將結果作為回傳值返回呼叫者。

------

### `執行邏輯運算`

#### 功能概述

`執行邏輯運算` 是 `位元陣列` 類別的私有方法，用於在兩個位元陣列之間執行邏輯運算（如 AND、OR 和 XOR），並返回一個包含運算結果的新 `位元陣列`。它確保了位元陣列的長度相符後，逐位元進行計算，並處理結果分頁存儲。

------

#### 技術結構

1. 參考另一個 `位元陣列` 的資料進行逐頁邏輯運算
   - 通過`運算符`參數（`and`, `or`, `xor`）作為邏輯選擇器。
   - 使用位元操作 (如 `&`, `|`, `^`) 高效實現位元數據運算。
2. 結果為新建的位元陣列
   - 運算結果存儲到新生成的位元陣列中，避免影響原始數據。

------

#### 參數規格與回傳

##### 方法參數

| 參數名稱   | 類型       | 描述                                                         | 必要性 |
| ---------- | ---------- | ------------------------------------------------------------ | ------ |
| 另一個向量 | `位元陣列` | 欲進行邏輯運算的位元陣列，其位元數量必須與當前位元陣列一致。 | 是     |
| 運算符     | `string`   | 決定使用的邏輯運算類型。支援以下值<br />： `'and'`（邏輯且）、`'or'`（邏輯或）與 `'xor'`（邏輯異或）。 | 是     |

##### 回傳值

| 回傳值   | 類型       | 描述                                             |
| -------- | ---------- | ------------------------------------------------ |
| 運算結果 | `位元陣列` | 返回一個新的位元陣列，包含執行邏輯運算後的結果。 |

------

#### 循序圖

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者 as 使用者
    participant 位元陣列1 as 位元陣列 A
    participant 位元陣列2 as 位元陣列 B
    participant 新位元陣列 as 運算結果

    使用者->>位元陣列1: 呼叫執行邏輯運算方法
    位元陣列1-->>位元陣列2: 檢查位元數量是否相符
    位元陣列1->>新位元陣列: 初始化新位元陣列
    loop 對所有頁面逐一進行
        位元陣列1->>新位元陣列: 計算結果並填充頁面
    end
    位元陣列1-->>使用者: 返回新位元陣列
```

------

#### 程式邏輯

1. **驗證參數有效性**：
   - 確保傳入的 `另一個向量` 是一個有效的 `位元陣列` 並且其長度與當前 `位元陣列` 相同。
   - 如果任一條件不符合，則拋出 `參數錯誤` 的例外。
2. **根據邏輯運算符選擇對應運算**：
   - 建立一個運算映射表來對應：
     - `and` 對應 `a & b`
     - `or` 對應 `a | b`
     - `xor` 對應 `a ^ b`
3. **初始化新位元陣列**：
   - 新位元陣列的長度與當前 `位元陣列` 相同。
4. **執行頁面級邏輯計算**：
   - 逐頁調用對應的邏輯運算符計算每頁數據，並將結果填入新位元陣列的 `#頁面` 陣列中。
5. **返回運算結果**：
   - 最終結果為新的 `位元陣列` 實例。

------

### `確保二進位字串只有0和1的字元`

#### 功能概述

此方法的主要功能是驗證一個給定的字串是否只包含合法的二進位元字元 (`0` 和 `1`)。
 如果字串中存在任何非 `0` 或 `1` 的字元，該方法將拋出一個 `二進位字串內容錯誤` 的例外。
 此方法用於確保二進位字串的格式正確，以避免後續處理時出現數據錯誤。

#### 技術結構

該方法屬於私有方法 (`#` 前綴) 並且內部使用迴圈遍歷輸入字串的每個字元進行檢查。
 觸發的例外為 `二進位字串內容錯誤`，必須在作業前正確捕捉錯誤來進一步處理。

#### 參數規格與回傳

| **參數名稱** | **類型** | **描述**               | **必要性** |
| ------------ | -------- | ---------------------- | ---------- |
| `字串`       | `string` | 欲進行檢查的二進位字串 | 必要       |

##### 回傳值：

| **回傳值** | **類型** | **描述**                               |
| ---------- | -------- | -------------------------------------- |
| 無         | 無       | 此方法不回傳值，若驗證失敗將拋出例外。 |

------

#### 循序圖

```mermaid
sequenceDiagram
    autoNumber
    participant 呼叫者 as 呼叫者
    participant 方法 as #確保二進位字串只有0和1的字元
    participant 例外 as 二進位字串內容錯誤
    呼叫者->>方法: 傳入字串
    方法->>方法: 檢查字串是否為空
    alt 字串為空
        方法->>呼叫者: 無操作，結束
    else 字串非空
        方法->>方法: 迴圈檢查每個字元
        alt 字元合法（0或1）
            方法->>方法: 繼續下一個字元
        else 字元非法
            方法->>例外: 拋出二進位字串內容錯誤
        end
    end
```

------

#### 程式邏輯

1. **初始化輸入字串檢查**
      若字串為空則無需處理，直接返回，方法結束。
2. **遍歷字串中的每個字元**
      使用迴圈檢查字串中的所有字元，是否為 `'0'` 或 `'1'`。
3. **拋出例外**
      若檢測到任一字元非合法的二進位元字元（即既非 `'0'` 也非 `'1'`），即刻拋出 `二進位字串內容錯誤` 例外，並附帶錯誤訊息。
4. **結束檢查**
      若所有字元均合法，則方法結束且不執行額外操作。

------

### `確定位元編號在範圍內`

#### 功能概述

`#確定位元編號在範圍內` 方法是一個私有方法，用於確保提供的位元編號為有效的數值，且位於合法範圍內。它主要用於內部驗證操作，以防止無效的位元編號導致程序邏輯出錯。

#### 技術結構

該方法首先檢查位元編號是否為數值類型，若不是則拋出 `型別錯誤`。接著，它驗證位元編號是否在合法範圍內 `[0, this.#數量 - 1]`，若範圍超出則拋出 `索引超出範圍錯誤`。

#### 參數規格與回傳

| **參數名稱** | **類型** | **描述**                                                   | **必要性** |
| ------------ | -------- | ---------------------------------------------------------- | ---------- |
| 位元編號     | `number` | 欲檢查的位元編號，必須是數值，範圍為 `[0, this.#數量 - 1]` | 是         |

| **回傳值** | **類型** | **描述**                                                     |
| ---------- | -------- | ------------------------------------------------------------ |
| 無         | 無       | 這是一個用於驗證的私有方法，不回傳任何值。若驗證失敗，會拋出錯誤。 |

#### 錯誤拋出

| **錯誤名稱**       | **描述**                                                     |
| ------------------ | ------------------------------------------------------------ |
| `型別錯誤`         | 當位元編號的類型不是數值時，拋出此錯誤。                     |
| `索引超出範圍錯誤` | 當位元編號超出合法範圍（即小於 0 或大於等於位元總數量）時拋出。 |

#### 循序圖

以下是 `#確定位元編號在範圍內` 方法的執行流程：

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者程式
    participant 確定位元編號在範圍內
    使用者程式->>確定位元編號在範圍內: 傳入位元編號
    確定位元編號在範圍內->>確定位元編號在範圍內: 驗證是否為數值
    alt 位元編號不是數值
        確定位元編號在範圍內->>使用者程式: 拋出型別錯誤
    else 位元編號是數值
        確定位元編號在範圍內->>確定位元編號在範圍內: 驗證是否在合法範圍內
        alt 位元編號不在合法範圍
            確定位元編號在範圍內->>使用者程式: 拋出索引超出範圍錯誤
        else 位元編號在合法範圍
            確定位元編號在範圍內-->>使用者程式: 驗證通過
        end
    end
```

#### 程式邏輯

以下是 `#確定位元編號在範圍內` 方法的邏輯步驟描述：

1. **驗證類型**
       驗證參數 `位元編號` 是否為數值類型。
   - 若不是數值，拋出 `型別錯誤`，錯誤訊息為 `"位元編號必須是數值"`。
2. **檢查合法範圍**
       確保位元編號位於範圍 `[0, this.#數量 - 1]`。
   - 若位元編號小於 0 或大於等於 `this.#數量`，拋出 `索引超出範圍錯誤`，錯誤訊息為：

```
位元編號必須在(0, this.#數量 - 1)之間。
```

1. **成功通過驗證**
       若參數通過所有驗證，方法結束，返回至呼叫方。

------

### `計算需要的頁面數量`

#### 功能概述

`計算需要的頁面數量` 是一個私有方法，用於根據指定的位元數量，計算位元陣列存儲這些位元所需的頁面數量。頁面的劃分依據 `#一頁可紀錄的位元數` 設定，支援處理大數據的位元分頁邏輯。

#### 技術結構

此方法使用數學公式計算頁面數量，保證計算結果向上取整以容納所有位元數，即使未整除每頁容量的情況。核心公式如下：

```
Math.floor((位元數量 + 每頁可紀錄位元數 - 1) / 每頁可紀錄位元數)
```

此公式核心邏輯是為了實現向上取整，可有效避免浮點運算。

#### 參數規格與回傳

| 參數名稱 | 類型   | 描述                               | 必要性 |
| -------- | ------ | ---------------------------------- | ------ |
| 位元數量 | Number | 欲存儲的總位元數量，必須是非負整數 | 必要   |

**回傳值**

| 回傳值   | 類型   | 描述                                               |
| -------- | ------ | -------------------------------------------------- |
| 頁面數量 | Number | 計算的頁面總數，用以存儲指定的位元數量所需的頁面數 |

#### 循序圖

以下為此方法的運作邏輯循序圖：

```mermaid
sequenceDiagram
    autoNumber
    participant 呼叫者
    participant 方法計算需要的頁面數量
    呼叫者->>方法計算需要的頁面數量: 提供位元數量參數
    方法計算需要的頁面數量->>方法計算需要的頁面數量: 使用計算公式平均劃分
    方法計算需要的頁面數量-->>呼叫者: 返回頁面數量結果
```

#### 程式邏輯

1. 接收一個參數 `位元數量`，其值表示要存儲的位元總數。
2. 讀取私有屬性 `#一頁可紀錄的位元數`，作為內部分頁依據。
3. 使用公式計算所需的頁面數量：   
   - 公式：`Math.floor((位元數量 + this.#一頁可紀錄的位元數 - 1) / this.#一頁可紀錄的位元數)`。
   - 說明：     
     - 加上 `(每頁容量 - 1)` 可實現向上取整效果。
     - 計算結果為頁數，確保餘數部分也能妥善分配到額外的頁面。
4. 返回計算的頁面總數。

------

### `設定位元數量`

#### 功能概述

`設定位元數量` 為位元陣列內部的私有方法，用來設定位元陣列的長度，並根據新的位元數量初始化頁面結構。此方法確保位元陣列能夠在長度變更後，重新初始化內部資料同時填充預設值（通常為 `0`）。

------

#### 技術結構

- 驗證傳入的位元數量是否合法（是否是非負數字）。
- 新的位元數量被計算出所需的分頁數量。
- 根據新位元數量，對內部頁面結構進行初始化，並填充為預設值 `0`。
- 更新總位元數量至新設定值，以匹配內部資料結構。

------

#### 參數規格與回傳

##### 參數

| 參數名稱 | 類型   | 描述                           | 是否必要 |
| -------- | ------ | ------------------------------ | -------- |
| 新數量   | Number | 新的位元數量，必須為非負整數。 | 必要     |

##### 回傳值

| 回傳值   | 類型   | 描述                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 無回傳值 | `void` | 該方法為內部設定函式，直接修改位元陣列的內部狀態無需回傳任何值。 |

------

#### 循序圖

```mermaid
sequenceDiagram
    autoNumber
    participant 使用者
    participant 設定位元數量方法
    participant 位元陣列內部屬性
    使用者->>設定位元數量方法: 呼叫(新數量)
    設定位元數量方法->>設定位元數量方法: 驗證參數合法性
    設定位元數量方法->>位元陣列內部屬性: 計算分頁數量
    設定位元數量方法->>位元陣列內部屬性: 初始化頁面數據，填充為 0
    設定位元數量方法->>位元陣列內部屬性: 更新總位元數量
    設定位元數量方法-->>使用者: 完成設定
```

------

#### 程式邏輯

1. 確認輸入的參數 `新數量` 是否為非負整數：
   - 若非數字或小於0，則拋出型別錯誤。
2. 根據新的位元數量計算所需頁面的數量：
   - 使用公式計算每頁所需的分頁。
3. 根據計算結果初始化頁面結構：
   - 設置新分頁數量，並將所有分頁的值預設為 `0`。
4. 更新內部的位元總數。
