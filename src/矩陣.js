import 向量 from './向量.js';
import { 型別錯誤, 索引超出範圍錯誤 } from './例外.js';
import 型別 from './型別.js';
import 錯誤訊息 from './錯誤訊息.js';






export default class 矩陣 extends Array {

	#橫列數量;
	#直行數量;
	#預設值;

	
	constructor (橫列數量 = 0, 直行數量 = 0, 預設值 = 0) {
		super();
		this.清除();
		this.#預設值 = 預設值;

		if (型別.是陣列(橫列數量)) {
			this.#以陣列做初始化(Array.from(arguments));
		} else {
			this.設定維度(橫列數量, 直行數量);
			this.填滿(this.#預設值);
		}
	}

	
	get 列秩 () {
		let 非零的橫列數量 = 0;
		let 上三角矩陣 = this.上三角矩陣();
		for (let 橫列編號 = 0; 橫列編號 < 上三角矩陣.橫列數量; 橫列編號++) {
			if (!this.橫列(橫列編號).是零向量()) {
				非零的橫列數量++;
			}
		}
		return 非零的橫列數量;
	}

	
	get 橫列數量 () {
		return this.#橫列數量;
	}

	
	get 特徵值 () {
		let 暫存矩陣 = this.複製();
		for (let 對角線編號 = 0; 對角線編號 < 暫存矩陣.#橫列數量 - 1; 對角線編號++) {
			for (let 橫列編號 = 對角線編號 + 1; 橫列編號 < 暫存矩陣.#橫列數量; 橫列編號++) {
				let 對角線元素 = 暫存矩陣[對角線編號][對角線編號];
				if (對角線元素 === 0) {
					暫存矩陣.交換橫列(對角線編號, 橫列編號);
					暫存矩陣.設定橫列(橫列編號, 暫存矩陣.橫列(橫列編號).乘(-1));
					continue;
				}
				let m = -1 * 暫存矩陣[橫列編號][對角線編號] / 對角線元素;
				let 橫列向量 = 暫存矩陣.橫列(橫列編號);
				橫列向量 = 橫列向量.加(暫存矩陣.橫列(對角線編號).乘(m));
				暫存矩陣.設定橫列(橫列編號, 橫列向量);
			}
		}

		let 回傳結果 = 暫存矩陣[0][0];
		for (let 對角線編號 = 1; 對角線編號 < 暫存矩陣.#橫列數量; 對角線編號++) {
			回傳結果 = 回傳結果 * 暫存矩陣[對角線編號][對角線編號];
		}
		return 回傳結果;
	}

	
	get 直行數量 () {
		return this.#直行數量;
	}

	
	static 單位矩陣 (橫列數量) {
		let 結果 = new 矩陣(橫列數量, 橫列數量);
		for (let 橫列 = 0; 橫列 < 橫列數量; 橫列++) {
			結果[橫列][橫列] = 1;
		}
		return 結果;
	}

	
	#乘以倍數 (倍數) {
		let 回傳結果 = new 矩陣(this.橫列數量, this.直行數量);
		for (let 橫列編號 = 0; 橫列編號 < this.橫列數量; 橫列編號++) {
			for (let 直行編號 = 0; 直行編號 < this.直行數量; 直行編號++) {
				回傳結果[橫列編號][直行編號] = this[橫列編號][直行編號] * 倍數;
			}
		}
		return 回傳結果;
	}

	
	#以陣列做初始化 (陣列集合) {
		const { 直行數量, 橫列數量 } = this.#從陣列集合計算維度(陣列集合);
		this.length = 0;

		陣列集合
			.filter(型別.是陣列)
			.forEach(array => {
				const 橫列 = Array.from({ length: 直行數量 }, (_, 直行編號) => array[直行編號] || 0);
				this.push(橫列);
			});

		this.#橫列數量 = 橫列數量;
		this.#直行數量 = 直行數量;
	}

	
	#加減運算 (目標, 加減數值, 加減矩陣) {
		const 加減運算 = 型別.是數字(目標)
			? 加減數值
			: (目標 instanceof 矩陣)
				? 加減矩陣
				: (() => {
					throw new 型別錯誤(錯誤訊息.矩陣.目標必須是數值或是矩陣);
				})();

		const 回傳結果 = new 矩陣(this.#橫列數量, this.#直行數量);
		for (let 橫列編號 = 0; 橫列編號 < this.#橫列數量; 橫列編號++) {
			for (let 直行編號 = 0; 直行編號 < this.#直行數量; 直行編號++) {
				加減運算(橫列編號, 直行編號, 回傳結果);
			}
		}
		return 回傳結果;
	}

	
	#參數值必須是向量或矩陣 (參數) {
		if (!(參數 instanceof 向量) && 型別.不是陣列(參數)) {
			throw new 型別錯誤(錯誤訊息.矩陣.參數值必須是向量或矩陣);
		}
	}

	
	#參數必須是矩陣型別 (目標) {
		if (!(目標 instanceof 矩陣)) {
			throw new 型別錯誤('目標的型別必須是矩陣。');
		}
	}

	
	#從陣列集合計算維度 (陣列集合) {
		return 陣列集合.reduce(
			(結果, 陣列) => {
				if (型別.不是陣列(陣列)) {
					return 結果;
				}
				return {
					直行數量: Math.max(結果.直行數量, 陣列.length),
					橫列數量: 結果.橫列數量 + 1,
				};
			},
			{ 直行數量: 0, 橫列數量: 0 }
		);
	}

	
	#橫列編號必須在範圍內 (橫列編號) {
		const 範圍上限 = this.#橫列數量 - 1;
		if (橫列編號 < 0 || 橫列編號 > 範圍上限) {
			throw new 索引超出範圍錯誤(`橫列編號超出範圍(0,${範圍上限})`);
		}
	}

	
	#直行編號必須在範圍內 (直行編號) {
		const 範圍上限 = this.#直行數量 - 1;
		if (直行編號 < 0 || 直行編號 > 範圍上限) {
			throw new 索引超出範圍錯誤(`直行編號超出範圍(0,${範圍上限})`);
		}
	}

	
	#高斯約旦消去法計算反矩陣 (矩陣) {
		// 前向消去
		矩陣.forEach((_, 對角線編號) => {
			const 主橫列 = 矩陣.橫列(對角線編號).乘(1 / 矩陣[對角線編號][對角線編號]);
			矩陣.設定橫列(對角線編號, 主橫列);

			for (let r = 對角線編號 + 1; r < 矩陣.橫列數量; r++) {
				const 消去橫列 = 矩陣.橫列(r).加(主橫列.乘(-矩陣[r][對角線編號]));
				矩陣.設定橫列(r, 消去橫列);
			}
		});

		// 反向消去
		for (let 對角線編號 = 矩陣.橫列數量 - 1; 對角線編號 > 0; 對角線編號--) {
			for (let r = 對角線編號; r > 0; r--) {
				if (矩陣[r - 1][對角線編號] === 0) {
					continue;
				} // 跳過不需要消去的情況

				const 消去橫列 = 矩陣.橫列(r - 1).加(
					矩陣.橫列(對角線編號).乘(-矩陣[r - 1][對角線編號])
				);
				矩陣.設定橫列(r - 1, 消去橫列);
			}
		}

		// 提取反矩陣
		return 矩陣.複製範圍(0, this.直行數量, this.橫列數量, this.直行數量);
	}

	
	上三角矩陣 () {
		const 回傳結果 = this.複製();

		回傳結果.forEach((row, 對角線編號) => {
			const 主行 = 回傳結果.橫列(對角線編號);
			for (let rowIndex = 對角線編號 + 1; rowIndex < 回傳結果.橫列數量; rowIndex++) {
				const 縮放因數 = -回傳結果[rowIndex][對角線編號] / 回傳結果[對角線編號][對角線編號];
				回傳結果.設定橫列(rowIndex, 回傳結果.橫列(rowIndex).加(主行.乘(縮放因數)));
			}
		});

		return 回傳結果;
	}

	
	乘 (目標) {
		if (型別.是數字(目標)) {
			return this.#乘以倍數(目標);
		}

		this.#參數必須是矩陣型別(目標);

		if (this.#直行數量 !== 目標.橫列數量) {
			throw new Error('目標的橫列數量應等於矩陣的直行數量。');
		}

		const 回傳結果 = new 矩陣(this.橫列數量, 目標.直行數量);

		回傳結果.forEach((_, row) => {
			回傳結果[row].forEach((_, column) => {
				回傳結果[row][column] = this[row].reduce(
					(sum, value, c) => sum + value * 目標[c][column],
					0
				);
			});
		});

		return 回傳結果;
	}

	
	交換橫列 (a, b) {
		this.#橫列編號必須在範圍內(a);
		this.#橫列編號必須在範圍內(b);
		[this[a], this[b]] = [this[b], this[a]];
		return this;
	}

	
	修正精確度誤差 () {
		this.forEach((橫列, 橫列編號) => {
			橫列.forEach((元素, 直行編號) => {
				this[橫列編號][直行編號] = 型別.修正精確度誤差(元素);
			});
		});
		return this;
	}

	
	冪次 (n) {
		if (n === 0) {
			return 矩陣.單位矩陣(this.橫列數量);
		}
		if (n === 1) {
			return this.複製();
		}

		let 回傳結果 = this.複製();
		for (let i = 2; i <= n; i++) {
			回傳結果 = 回傳結果.乘(this);
		}
		return 回傳結果;
	}

	
	加 (目標) {
		const 加上數值 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] + 目標;
		const 加上矩陣 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] + 目標[橫列編號][直行編號];
		return this.#加減運算(目標, 加上數值, 加上矩陣);
	}

	
	反矩陣 () {
		if (this.#直行數量 === 0 || this.#橫列數量 === 0) {
			throw new Error(錯誤訊息.矩陣.因為維度為0所以此矩陣沒有反矩陣);
		}
		if (this.特徵值 === 0) {
			throw new Error(錯誤訊息.矩陣.因為行列式為零所以此矩陣沒有反矩陣);
		}
		if (this.#直行數量 !== this.#橫列數量) {
			throw new Error(錯誤訊息.矩陣.因為不是方陣所以此矩陣沒有反矩陣);
		}

		const 單位矩陣 = 矩陣.單位矩陣(this.橫列數量);
		const 暫存矩陣 = this.合併直行(單位矩陣);

		return this.#高斯約旦消去法計算反矩陣(暫存矩陣);
	}

	
	合併直行 (m) {
		const 新矩陣 = new 矩陣(this.橫列數量, this.直行數量 + m.直行數量);
		this.forEach((橫列, 橫列編號) => {
			新矩陣[橫列編號] = [...橫列, ...m[橫列編號]];
		});
		return 新矩陣;
	}

	
	填滿 (值) {
		this.forEach(row => row.fill(值));
		return this;
	}

	
	是反對稱矩陣 () {
		return this.轉置矩陣().等於(this.乘(-1));
	}

	
	是對稱矩陣 () {
		return this.轉置矩陣().等於(this);
	}

	
	是方塊矩陣 () {
		return this.#橫列數量 === this.#直行數量;
	}

	
	橫列 (橫列編號) {
		return new 向量(this[橫列編號]);
	}

	
	每一個元素 (回呼函式) {
		this.forEach((橫列, 橫列編號) =>
			橫列.forEach((元素, 直行編號) =>
				回呼函式(元素, 橫列編號, 直行編號)
			)
		);
		return this;
	}

	
	每一個橫列 (回呼函式) {
		this.forEach((橫列, 橫列編號) => 回呼函式(橫列, 橫列編號));
		return this;
	}

	
	每一個直行 (回呼函式) {
		this.#直行數量 && Array.from({ length: this.#直行數量 }, (_, 直行編號) =>
			回呼函式(this.直行(直行編號), 直行編號)
		);
		return this;
	}

	
	清除 () {
		this.length = 0;
		this.#橫列數量 = 0;
		this.#直行數量 = 0;
		return this;
	}

	
	減 (目標) {
		const 減去數值 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] - 目標;
		const 減去矩陣 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] - 目標[橫列編號][直行編號];
		return this.#加減運算(目標, 減去數值, 減去矩陣);
	}

	
	直行 (直行編號) {
		return this.map(橫列 => 橫列[直行編號]);
	}

	
	等於 (目標) {
		if (!(目標 instanceof 矩陣)) {
			throw new 型別錯誤(錯誤訊息.矩陣.參數值必須是矩陣);
		}

		if (
			this.#橫列數量 !== 目標.橫列數量 ||
			this.#直行數量 !== 目標.直行數量
		) {
			return false;
		}

		return this.flat().every((值, 索引) => 值 === 目標.flat()[索引]);
	}

	
	總和 (初始值 = 0) {
		return this.flat().reduce((加總, 元素) => 加總 + 元素, 初始值);
	}

	
	複製 () {
		return this.複製範圍(0, 0, this.#橫列數量, this.#直行數量);
	}

	
	複製範圍 (起始橫列編號, 起始直行編號, 橫列數量, 直行數量) {
		this.#橫列編號必須在範圍內(起始橫列編號);
		this.#直行編號必須在範圍內(起始直行編號);

		if (橫列數量 <= 0 || 直行數量 <= 0) {
			throw new Error('橫列數量和直行數量必須大於零');
		}
		if (起始橫列編號 + 橫列數量 > this.#橫列數量 || 起始直行編號 + 直行數量 > this.#直行數量) {
			throw new Error('範圍超出矩陣邊界');
		}

		const 回傳結果 = new 矩陣(橫列數量, 直行數量);

		回傳結果.forEach((row, 橫列索引) => {
			row.forEach((_, 直行索引) => {
				row[直行索引] = this[起始橫列編號 + 橫列索引][起始直行編號 + 直行索引];
			});
		});

		return 回傳結果;
	}

	
	設定橫列 (橫列編號, 值) {
		this.#橫列編號必須在範圍內(橫列編號);
		this.#參數值必須是向量或矩陣(值);

		this[橫列編號] = Array.from({ length: this.#直行數量 }, (_, 直行編號) => 值[直行編號]);

		return this;
	}

	
	設定直行 (直行編號, 值) {
		this.#直行編號必須在範圍內(直行編號);
		this.#參數值必須是向量或矩陣(值);

		this.forEach((row, 橫列編號) => {
			row[直行編號] = 值[橫列編號];
		});

		return this;
	}

	
	設定維度 (新的橫列數量, 新的直行數量) {
		this.#橫列數量 = 新的橫列數量;
		this.#直行數量 = 新的直行數量;
		this.length = 0; // 清空現有元素
		this.push(...Array.from({ length: this.#橫列數量 },
			() => Array(this.#直行數量).fill(this.#預設值)
		));
		return this;
	}

	
	轉為字串 () {
		let 回傳結果 = '[\r\n';
		this.forEach((row) => {
			回傳結果 += '  [' +
				row.reduce((acc, curr) => acc + ' ' +
					型別.修正精確度誤差((型別.是很小的值(curr) ? 0 : curr)) + ' ', '');
			回傳結果 += ']\r\n';
		});
		回傳結果 += ']\r\n';
		return 回傳結果;
	}

	
	轉置矩陣 () {
		if (!this.#直行數量 || !this.#橫列數量) {
			throw new Error(錯誤訊息.矩陣.矩陣維度為0不可轉置);
		}
		const 回傳結果 = new 矩陣(this.#直行數量, this.#橫列數量);
		回傳結果.forEach((_, 橫列編號) => {
			回傳結果[橫列編號] = this.map((行) => 行[橫列編號]);
		});
		return 回傳結果;
	}
};
