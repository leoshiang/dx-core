const 向量 = require('./向量');
const { 型別錯誤, 索引超出範圍錯誤 } = require('./例外');
const 型別 = require('./型別');
const 錯誤訊息 = require('./錯誤訊息');

/**
 * 此 callback 會在遍歷每一個 直行 時被呼叫一次。
 *
 * @callback 矩陣回呼函式
 * @param {*} value 向量。
 * @param {*} 編號  直行/橫列 編號。
 */

/**
 * 此 callback 會在遍歷每一個元素時被呼叫一次。
 *
 * @callback forEachCallback
 * @param {*} value 值。
 * @param {*} 橫列  橫列 編號。
 * @param {*} 直行  直行 編號。
 */

/**
 * 矩陣類別
 *
 * @class 矩陣
 * @extends Array
 * @classdesc
 * 此類別表示一個二維陣列，基於 JavaScript 的原生 `Array` 類別進行擴展。
 * 矩陣可用於數學運算或作為數據處理中的二維結構，支援所有 `Array` 方法，
 * 同時可以進一步擴展實現特定的矩陣運算（如轉置、加法、乘法等功能）。
 *
 * @example
 * // 範例 1: 創建一個空的矩陣
 * const matrix1 = new 矩陣();
 * console.log(matrix1); // 輸出: []
 *
 * @example
 * // 範例 2: 創建一個初始值的矩陣
 * const matrix2 = new 矩陣(
 *   [1, 2, 3],
 *   [4, 5, 6],
 *   [7, 8, 9]
 * );
 * console.log(matrix2);
 * // 輸出:
 * // [
 * //   [1, 2, 3],
 * //   [4, 5, 6],
 * //   [7, 8, 9]
 * // ]
 *
 * @example
 * // 範例 3: 獲取矩陣的行列值
 * const matrix3 = new 矩陣(
 *   [1, 2, 3],
 *   [4, 5, 6]
 * );
 * console.log(matrix3[0][1]); // 獲取第 0 行第 1 列的值，輸出: 2
 *
 * @example
 * // 範例 4: 擴展矩陣功能 (矩陣轉置)
 * 矩陣.prototype.轉置 = function () {
 *   const rows = this.length;
 *   const cols = this[0]?.length || 0;
 *   const transposed = new 矩陣();
 *   for (let i = 0; i < cols; i++) {
 *     transposed.push([]);
 *     for (let j = 0; j < rows; j++) {
 *       transposed[i].push(this[j][i]);
 *     }
 *   }
 *   return transposed;
 * };
 * const matrix4 = new 矩陣(
 *   [1, 2],
 *   [3, 4],
 *   [5, 6]
 * );
 * const transposed = matrix4.轉置();
 * console.log(transposed);
 * // 輸出:
 * // [
 * //   [1, 3, 5],
 * //   [2, 4, 6]
 * // ]
 */
module.exports = class 矩陣 extends Array {

	#橫列數量;
	#直行數量;
	#預設值;

	/**
	 * 建構一個矩陣物件。
	 *
	 * @constructor
	 * @param {number|Array} [橫列數量=0] 橫列數，或以陣列表示的矩陣數據。
	 * @param {number|Array} [直行數量=0] 直行數，僅當第一個參數為數字時生效。
	 * @param {number} [預設值=0] 矩陣的預設值，用於填充矩陣的每個元素。
	 *
	 * @example
	 * // 建立空的矩陣
	 * let m1 = new 矩陣(); // []
	 *
	 * // 建立2x2矩陣，填滿預設值0
	 * let m2 = new 矩陣(2, 2); // [[0, 0], [0, 0]]
	 *
	 * // 以多維陣列初始化矩陣
	 * let m3 = new 矩陣(
	 *   [2, 3, 1],
	 *   [4, 7, 2],
	 *   [3, 1, 1]
	 * ); // [[2, 3, 1], [4, 7, 2], [3, 1, 1]]
	 *
	 * // 混合使用多維陣列與單獨一行初始化
	 * let m4 = new 矩陣(
	 *   [2, 3, 1],
	 *   1,
	 *   [3, 1, 1]
	 * ); // [[2, 3, 1], [3, 1, 1]]
	 */
	constructor (橫列數量 = 0, 直行數量 = 0, 預設值 = 0) {
		super();
		this.清除();
		this.#預設值 = 預設值;

		if (型別.是陣列(橫列數量)) {
			this.#以陣列做初始化(Array.from(arguments));
		} else {
			this.設定維度(橫列數量, 直行數量);
			this.填滿(this.#預設值);
		}
	}

	/**
	 * 取得矩陣的列秩（Rank）。
	 * 列秩表示矩陣中非零橫列（Row）的數量。
	 *
	 * @readonly
	 * @type {number}
	 * @returns {number} 矩陣的列秩，即非零橫列的數量。
	 *
	 * @example
	 * let m = new 矩陣(
	 *    [1, 0, 0],
	 *    [0, 2, 0],
	 *    [0, 0, 0]
	 * );
	 * console.log(m.列秩); // 2
	 */
	get 列秩 () {
		let 非零的橫列數量 = 0;
		let 上三角矩陣 = this.上三角矩陣();
		for (let 橫列編號 = 0; 橫列編號 < 上三角矩陣.橫列數量; 橫列編號++) {
			if (!this.橫列(橫列編號).是零向量()) {
				非零的橫列數量++;
			}
		}
		return 非零的橫列數量;
	}

	/**
	 * 取得矩陣的橫列數量。
	 *
	 * @readonly
	 * @type {number}
	 * @returns {number} 矩陣的橫列數量（Row count）。
	 *
	 * @example
	 * let m = new 矩陣(3, 4); // 建立一個 3 行 4 列的矩陣
	 * console.log(m.橫列數量); // 3
	 */
	get 橫列數量 () {
		return this.#橫列數量;
	}

	/**
	 * 計算並取得矩陣的特徵值（Determinant）。
	 *
	 * @readonly
	 * @type {number}
	 * @returns {number} 矩陣的特徵值（又稱行列式 determinant）的數值結果。
	 *
	 * @throws {Error} 如果矩陣為無效矩陣（如維度為 0），可能會拋出錯誤。
	 *
	 * @example
	 * let m = new 矩陣(
	 *   [2, 3],
	 *   [1, 4]
	 * );
	 * console.log(m.特徵值); // 顯示行列式的值，比如 5
	 *
	 * let n = new 矩陣(
	 *   [0, 0],
	 *   [0, 0]
	 * );
	 * console.log(n.特徵值); // 顯示 0，因為行列式為 0
	 */
	get 特徵值 () {
		let 暫存矩陣 = this.複製();
		for (let 對角線編號 = 0; 對角線編號 < 暫存矩陣.#橫列數量 - 1; 對角線編號++) {
			for (let 橫列編號 = 對角線編號 + 1; 橫列編號 < 暫存矩陣.#橫列數量; 橫列編號++) {
				let 對角線元素 = 暫存矩陣[對角線編號][對角線編號];
				if (對角線元素 === 0) {
					暫存矩陣.交換橫列(對角線編號, 橫列編號);
					暫存矩陣.設定橫列(橫列編號, 暫存矩陣.橫列(橫列編號).乘(-1));
					continue;
				}
				let m = -1 * 暫存矩陣[橫列編號][對角線編號] / 對角線元素;
				let 橫列向量 = 暫存矩陣.橫列(橫列編號);
				橫列向量 = 橫列向量.加(暫存矩陣.橫列(對角線編號).乘(m));
				暫存矩陣.設定橫列(橫列編號, 橫列向量);
			}
		}

		let 回傳結果 = 暫存矩陣[0][0];
		for (let 對角線編號 = 1; 對角線編號 < 暫存矩陣.#橫列數量; 對角線編號++) {
			回傳結果 = 回傳結果 * 暫存矩陣[對角線編號][對角線編號];
		}
		return 回傳結果;
	}

	/**
	 * 取得矩陣的直行數量。
	 *
	 * @readonly
	 * @type {number}
	 * @returns {number} 矩陣的直行數量（Column count）。
	 *
	 * @example
	 * let m = new 矩陣(3, 4); // 建立一個 3 行 4 列的矩陣
	 * console.log(m.直行數量); // 4
	 */
	get 直行數量 () {
		return this.#直行數量;
	}

	/**
	 * 建立一個指定維度的單位矩陣（Identity Matrix）。
	 * 單位矩陣的特性是對角線上的元素為 1，其餘元素為 0。
	 *
	 * @static
	 * @param {number} 橫列數量 矩陣的橫列數量（即矩陣的維度）。
	 * @returns {矩陣} 一個新的單位矩陣物件。
	 *
	 * @throws {Error} 如果未提供有效的橫列數量或橫列數量小於 1，將拋出錯誤。
	 *
	 * @example
	 * // 建立 3x3 的單位矩陣
	 * let m = 矩陣.單位矩陣(3);
	 * console.log(m); // [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
	 *
	 * @example
	 * // 建立 2x2 的單位矩陣
	 * let m = 矩陣.單位矩陣(2);
	 * console.log(m); // [[1, 0], [0, 1]]
	 */
	static 單位矩陣 (橫列數量) {
		let 結果 = new 矩陣(橫列數量, 橫列數量);
		for (let 橫列 = 0; 橫列 < 橫列數量; 橫列++) {
			結果[橫列][橫列] = 1;
		}
		return 結果;
	}

	/**
	 * 將當前矩陣的每個元素乘以指定的倍數，並回傳一個新的矩陣。
	 *
	 * @private
	 * @param {number} 倍數 要乘以的數值。
	 * @returns {矩陣} 新的矩陣，每個元素均為原矩陣對應元素乘以指定倍數的結果。
	 *
	 * @example
	 * let m = new 矩陣(
	 *   [1, 2],
	 *   [3, 4]
	 * );
	 * let 結果 = m.#乘以倍數(2);
	 * console.log(結果); // [[2, 4], [6, 8]]
	 *
	 * @throws {Error} 如果倍數不是有效的數字，將拋出錯誤。
	 */
	#乘以倍數 (倍數) {
		let 回傳結果 = new 矩陣(this.橫列數量, this.直行數量);
		for (let 橫列編號 = 0; 橫列編號 < this.橫列數量; 橫列編號++) {
			for (let 直行編號 = 0; 直行編號 < this.直行數量; 直行編號++) {
				回傳結果[橫列編號][直行編號] = this[橫列編號][直行編號] * 倍數;
			}
		}
		return 回傳結果;
	}

	/**
	 * 使用給定的二維陣列集合來初始化矩陣，將每個子陣列轉換為矩陣的橫列。
	 * 若子陣列的長度不足，將用 0 補齊；若多於矩陣的直行數量，多餘的部分會被忽略。
	 *
	 * @private
	 * @param {Array<Array<number>>} 陣列集合 一個包含多個數字陣列的二維陣列，用於初始化矩陣。
	 * @throws {Error} 若輸入的陣列集合不是有效的二維陣列，將拋出錯誤。
	 *
	 * @example
	 * let 矩陣實例 = new 矩陣();
	 * 矩陣實例.#以陣列做初始化([
	 *   [1, 2, 3],
	 *   [4, 5],
	 *   [6, 7, 8, 9]
	 * ]);
	 * console.log(矩陣實例); // [[1, 2, 3], [4, 5, 0], [6, 7, 8]]
	 *
	 * @example
	 * 矩陣實例.#以陣列做初始化([]);
	 * console.log(矩陣實例); // 初始化為空矩陣
	 */
	#以陣列做初始化 (陣列集合) {
		const { 直行數量, 橫列數量 } = this.#從陣列集合計算維度(陣列集合);
		this.length = 0;

		陣列集合
			.filter(型別.是陣列)
			.forEach(array => {
				const 橫列 = Array.from({ length: 直行數量 }, (_, 直行編號) => array[直行編號] || 0);
				this.push(橫列);
			});

		this.#橫列數量 = 橫列數量;
		this.#直行數量 = 直行數量;
	}

	/**
	 * 執行加減運算，用於對矩陣或數值進行矩陣層級的加法或減法操作。
	 *
	 * @private
	 * @param {number|矩陣} 目標 傳入的目標，可以是單一數值或另一個矩陣。
	 * @param {Function} 加減數值 執行數值加減運算的函式。
	 * @param {Function} 加減矩陣 執行矩陣加減運算的函式。
	 * @returns {矩陣} 回傳一個新的矩陣，代表加減運算的結果。
	 *
	 * @throws {型別錯誤} 如果目標既不是數值也不是矩陣，則會拋出型別錯誤。
	 *
	 * @example
	 * // 對矩陣進行數值加法運算
	 * let 結果 = 原矩陣.#加減運算(5,
	 *   (橫列編號, 直行編號, 回傳結果) => {
	 *     回傳結果[橫列編號][直行編號] = 原矩陣[橫列編號][直行編號] + 5;
	 *   },
	 *   null
	 * );
	 * console.log(結果); // [[x+5, y+5, ...], ...]
	 *
	 * @example
	 * // 對矩陣進行矩陣加法運算
	 * let 結果 = 原矩陣.#加減運算(另一矩陣,
	 *   null,
	 *   (橫列編號, 直行編號, 回傳結果) => {
	 *     回傳結果[橫列編號][直行編號] =
	 *       原矩陣[橫列編號][直行編號] + 另一矩陣[橫列編號][直行編號];
	 *   }
	 * );
	 * console.log(結果); // [[x+x2, y+y2, ...], ...]
	 */
	#加減運算 (目標, 加減數值, 加減矩陣) {
		const 加減運算 = 型別.是數字(目標)
			? 加減數值
			: (目標 instanceof 矩陣)
				? 加減矩陣
				: (() => {
					throw new 型別錯誤(錯誤訊息.矩陣.目標必須是數值或是矩陣);
				})();

		const 回傳結果 = new 矩陣(this.#橫列數量, this.#直行數量);
		for (let 橫列編號 = 0; 橫列編號 < this.#橫列數量; 橫列編號++) {
			for (let 直行編號 = 0; 直行編號 < this.#直行數量; 直行編號++) {
				加減運算(橫列編號, 直行編號, 回傳結果);
			}
		}
		return 回傳結果;
	}

	/**
	 * 驗證參數是否為向量或矩陣，若參數不符合條件，則拋出型別錯誤。
	 *
	 * @private
	 * @param {向量|Array} 參數 傳入的參數，必須是向量或矩陣（以二維陣列表示）。
	 * @throws {型別錯誤} 如果參數既不是向量也不是矩陣，則拋出型別錯誤。
	 *
	 * @example
	 * // 正確使用 - 向量參數
	 * 矩陣實例.#參數值必須是向量或矩陣(new 向量([1, 2, 3])); // 不拋出錯誤
	 *
	 * @example
	 * // 正確使用 - 矩陣參數
	 * 矩陣實例.#參數值必須是向量或矩陣([[1, 2], [3, 4]]); // 不拋出錯誤
	 *
	 * @example
	 * // 錯誤使用 - 非向量或矩陣
	 * 矩陣實例.#參數值必須是向量或矩陣({}); // 拋出型別錯誤
	 * 矩陣實例.#參數值必須是向量或矩陣(123); // 拋出型別錯誤
	 */
	#參數值必須是向量或矩陣 (參數) {
		if (!(參數 instanceof 向量) && 型別.不是陣列(參數)) {
			throw new 型別錯誤(錯誤訊息.矩陣.參數值必須是向量或矩陣);
		}
	}

	/**
	 * 驗證參數是否為矩陣型別，若參數不是矩陣型別，則拋出型別錯誤。
	 *
	 * @private
	 * @param {矩陣} 目標 傳入的參數，必須是矩陣型別。
	 * @throws {型別錯誤} 如果參數的型別不是矩陣，則拋出型別錯誤。
	 *
	 * @example
	 * // 正確使用
	 * 矩陣實例.#參數必須是矩陣型別(另一個矩陣實例); // 不拋出錯誤
	 *
	 * @example
	 * // 錯誤使用
	 * 矩陣實例.#參數必須是矩陣型別(123); // 拋出型別錯誤
	 * 矩陣實例.#參數必須是矩陣型別('矩陣'); // 拋出型別錯誤
	 * 矩陣實例.#參數必須是矩陣型別([1, 2, 3]); // 拋出型別錯誤
	 */
	#參數必須是矩陣型別 (目標) {
		if (!(目標 instanceof 矩陣)) {
			throw new 型別錯誤('目標的型別必須是矩陣。');
		}
	}

	/**
	 * 計算給定陣列集合的維度，找出其中最長的子陣列長度作為直行數量，以及有效的陣列數量作為橫列數量。
	 *
	 * @private
	 * @param {Array<Array<*>>} 陣列集合 一個包含多個子陣列的陣列，每個元素應為陣列。
	 * @returns {{直行數量: number, 橫列數量: number}} 回傳一個物件，分別表示直行數量（最長陣列的長度）與橫列數量（有效陣列的個數）。
	 *
	 * @example
	 * // 計算維度
	 * let 維度 = 矩陣實例.#從陣列集合計算維度([[1, 2], [3], [4, 5, 6]]);
	 * console.log(維度); // { 直行數量: 3, 橫列數量: 3 }
	 *
	 * @example
	 * // 忽略無效元素
	 * let 維度 = 矩陣實例.#從陣列集合計算維度([[1], "文字", [2, 3]]);
	 * console.log(維度); // { 直行數量: 2, 橫列數量: 2 }
	 */
	#從陣列集合計算維度 (陣列集合) {
		return 陣列集合.reduce(
			(結果, 陣列) => {
				if (型別.不是陣列(陣列)) {
					return 結果;
				}
				return {
					直行數量: Math.max(結果.直行數量, 陣列.length),
					橫列數量: 結果.橫列數量 + 1,
				};
			},
			{ 直行數量: 0, 橫列數量: 0 }
		);
	}

	/**
	 * 驗證橫列編號是否在有效範圍內，若超出範圍則拋出索引超出範圍的錯誤。
	 *
	 * @private
	 * @param {number} 橫列編號 欲驗證的橫列編號，必須在範圍內（0 到 橫列數量 - 1）。
	 * @throws {索引超出範圍錯誤} 當橫列編號小於 0 或大於等於橫列數量時，拋出此錯誤。
	 *
	 * @example
	 * // 正確使用
	 * 矩陣實例.#橫列編號必須在範圍內(2); // 若矩陣有 3 橫列，此不拋出錯誤
	 *
	 * @example
	 * // 錯誤使用
	 * 矩陣實例.#橫列編號必須在範圍內(-1); // 拋出索引超出範圍錯誤
	 * 矩陣實例.#橫列編號必須在範圍內(5); // 拋出索引超出範圍錯誤（假設橫列數量為 4）
	 */
	#橫列編號必須在範圍內 (橫列編號) {
		const 範圍上限 = this.#橫列數量 - 1;
		if (橫列編號 < 0 || 橫列編號 > 範圍上限) {
			throw new 索引超出範圍錯誤(`橫列編號超出範圍(0,${範圍上限})`);
		}
	}

	/**
	 * 驗證直行編號是否在有效範圍內，如果超出範圍則拋出索引超出範圍的錯誤。
	 *
	 * @private
	 * @param {number} 直行編號 欲驗證的直行編號，必須在範圍內（0 到 直行數量 - 1）。
	 * @throws {索引超出範圍錯誤} 當直行編號小於 0 或大於等於直行數量時，拋出此錯誤。
	 *
	 * @example
	 * // 正確使用
	 * 矩陣實例.#直行編號必須在範圍內(3); // 若矩陣有 5 直行，此不拋出錯誤
	 *
	 * @example
	 * // 錯誤使用
	 * 矩陣實例.#直行編號必須在範圍內(-1); // 拋出索引超出範圍錯誤
	 * 矩陣實例.#直行編號必須在範圍內(6);  // 拋出索引超出範圍錯誤（假設直行數量為 5）
	 */
	#直行編號必須在範圍內 (直行編號) {
		const 範圍上限 = this.#直行數量 - 1;
		if (直行編號 < 0 || 直行編號 > 範圍上限) {
			throw new 索引超出範圍錯誤(`直行編號超出範圍(0,${範圍上限})`);
		}
	}

	/**
	 * 使用高斯約旦消去法計算給定矩陣的反矩陣。
	 *
	 * @private
	 * @param {矩陣} 矩陣 傳入的矩陣（必須為方陣），將以高斯約旦消去法進行計算。
	 * @returns {矩陣} 返回計算得到的反矩陣。
	 * @throws {錯誤} 當矩陣不是方陣或為不可逆時將拋出錯誤。
	 *
	 * @example
	 * // 計算反矩陣
	 * let 原矩陣 = new 矩陣([[2, 1], [7, 4]]);
	 * let 反矩陣 = 矩陣實例.#高斯約旦消去法計算反矩陣(原矩陣);
	 * console.log(反矩陣.數據); // [[4, -1], [-7, 2]]
	 *
	 * @example
	 * // 出現錯誤情況
	 * let 非可逆矩陣 = new 矩陣([[1, 1], [1, 1]]);
	 * 矩陣實例.#高斯約旦消去法計算反矩陣(非可逆矩陣); // 拋出錯誤：矩陣不可逆
	 */
	#高斯約旦消去法計算反矩陣 (矩陣) {
		// 前向消去
		矩陣.forEach((_, 對角線編號) => {
			const 主橫列 = 矩陣.橫列(對角線編號).乘(1 / 矩陣[對角線編號][對角線編號]);
			矩陣.設定橫列(對角線編號, 主橫列);

			for (let r = 對角線編號 + 1; r < 矩陣.橫列數量; r++) {
				const 消去橫列 = 矩陣.橫列(r).加(主橫列.乘(-矩陣[r][對角線編號]));
				矩陣.設定橫列(r, 消去橫列);
			}
		});

		// 反向消去
		for (let 對角線編號 = 矩陣.橫列數量 - 1; 對角線編號 > 0; 對角線編號--) {
			for (let r = 對角線編號; r > 0; r--) {
				if (矩陣[r - 1][對角線編號] === 0) {
					continue;
				} // 跳過不需要消去的情況

				const 消去橫列 = 矩陣.橫列(r - 1).加(
					矩陣.橫列(對角線編號).乘(-矩陣[r - 1][對角線編號])
				);
				矩陣.設定橫列(r - 1, 消去橫列);
			}
		}

		// 提取反矩陣
		return 矩陣.複製範圍(0, this.直行數量, this.橫列數量, this.直行數量);
	}

	/**
	 * 計算該矩陣的上三角矩陣。將矩陣轉換為上三角形格式，其中所有對角線以下的元素均為 0。
	 *
	 * @public
	 * @returns {矩陣} 回傳一個新的矩陣，表示對應的上三角矩陣。
	 *
	 * @example
	 * // 計算上三角矩陣
	 * let 矩陣 = new 矩陣([[2, 3, 1], [4, 5, 6], [7, 8, 9]]);
	 * let 上三角矩陣 = 矩陣.上三角矩陣();
	 * console.log(上三角矩陣.數據);
	 * // [
	 * //   [2, 3, 1],
	 * //   [0, 1, 4],
	 * //   [0, 0, 5]
	 * // ]
	 */
	上三角矩陣 () {
		const 回傳結果 = this.複製();

		回傳結果.forEach((row, 對角線編號) => {
			const 主行 = 回傳結果.橫列(對角線編號);
			for (let rowIndex = 對角線編號 + 1; rowIndex < 回傳結果.橫列數量; rowIndex++) {
				const 縮放因數 = -回傳結果[rowIndex][對角線編號] / 回傳結果[對角線編號][對角線編號];
				回傳結果.設定橫列(rowIndex, 回傳結果.橫列(rowIndex).加(主行.乘(縮放因數)));
			}
		});

		return 回傳結果;
	}

	/**
	 * 與另一個矩陣或數值進行相乘運算，返回相乘結果的新矩陣。
	 *
	 * @public
	 * @param {矩陣|number} 目標 可以是數值或矩陣。當參數為數值時，執行標量乘法；當參數為矩陣時，執行矩陣乘法。
	 * @returns {矩陣} 返回一個新的矩陣，表示相乘的結果。
	 * @throws {型別錯誤} 如果輸入目標既不是數值也不是矩陣，會拋出型別錯誤。
	 * @throws {錯誤} 如果矩陣乘法中，當前矩陣的直行數量與目標矩陣的橫列數量不一致，會拋出錯誤。
	 *
	 * @example
	 * // 與數值相乘
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 結果1 = 矩陣A.乘(2);
	 * console.log(結果1.數據); // [[2, 4], [6, 8]]
	 *
	 * @example
	 * // 矩陣乘法
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 矩陣B = new 矩陣([[5, 6], [7, 8]]);
	 * let 結果2 = 矩陣A.乘(矩陣B);
	 * console.log(結果2.數據); // [[19, 22], [43, 50]]
	 *
	 * @example
	 * // 無效的參數
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * 矩陣A.乘("無效參數"); // 拋出型別錯誤：目標不是矩陣或數值
	 */
	乘 (目標) {
		if (型別.是數字(目標)) {
			return this.#乘以倍數(目標);
		}

		this.#參數必須是矩陣型別(目標);

		if (this.#直行數量 !== 目標.橫列數量) {
			throw new Error('目標的橫列數量應等於矩陣的直行數量。');
		}

		const 回傳結果 = new 矩陣(this.橫列數量, 目標.直行數量);

		回傳結果.forEach((_, row) => {
			回傳結果[row].forEach((_, column) => {
				回傳結果[row][column] = this[row].reduce(
					(sum, value, c) => sum + value * 目標[c][column],
					0
				);
			});
		});

		return 回傳結果;
	}

	/**
	 * 交換矩陣中兩橫列的位置。
	 *
	 * @public
	 * @param {number} a 第一個橫列的索引（從 0 開始）。
	 * @param {number} b 第二個橫列的索引（從 0 開始）。
	 * @returns {矩陣} 返回交換完成的矩陣自身，供鏈式調用。
	 * @throws {索引超出範圍錯誤} 當橫列索引 `a` 或 `b` 不在矩陣的有效範圍內時，會拋出該錯誤。
	 *
	 * @example
	 * // 交換兩橫列
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * 矩陣A.交換橫列(0, 1);
	 * console.log(矩陣A.數據); // [[3, 4], [1, 2]]
	 *
	 * @example
	 * // 錯誤使用（索引超出範圍）
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * 矩陣A.交換橫列(0, 2); // 拋出索引超出範圍錯誤
	 */
	交換橫列 (a, b) {
		this.#橫列編號必須在範圍內(a);
		this.#橫列編號必須在範圍內(b);
		[this[a], this[b]] = [this[b], this[a]];
		return this;
	}

	/**
	 * 修正矩陣中所有數值的精確度誤差。
	 *
	 * 此方法遍歷矩陣中的每個元素，對其應用精確度修正，通常用於解決浮點計算時的細微數值誤差問題。
	 *
	 * @public
	 * @returns {矩陣} 返回修正精確度誤差後的矩陣自身，供鏈式調用。
	 *
	 * @example
	 * // 修正矩陣中的浮點精確度誤差
	 * let 矩陣A = new 矩陣([[0.1 + 0.2, 0.3], [0.15, 0.45 - 0.3]]);
	 * 矩陣A.修正精確度誤差();
	 * console.log(矩陣A.數據);
	 * // [[0.3, 0.3], [0.15, 0.15]] // 精確度誤差已修正
	 */
	修正精確度誤差 () {
		this.forEach((橫列, 橫列編號) => {
			橫列.forEach((元素, 直行編號) => {
				this[橫列編號][直行編號] = 型別.修正精確度誤差(元素);
			});
		});
		return this;
	}

	/**
	 * 計算該矩陣的整數次冪。
	 *
	 * 若 `n` 為 0，返回單位矩陣；若 `n` 為 1，返回矩陣的副本；若 `n` 為大於 1 的整數，則進行矩陣連續乘法。
	 *
	 * @public
	 * @param {number} n 指定矩陣的冪次（應為非負整數）。
	 * @returns {矩陣} 返回冪次計算後的新矩陣。
	 * @throws {錯誤} 如果 `n` 為負數，將拋出錯誤，因為該方法僅支援非負整數冪次。
	 *
	 * @example
	 * // 計算 n = 0 時的單位矩陣
	 * let 矩陣A = new 矩陣([[2, 3], [4, 5]]);
	 * let 單位矩陣 = 矩陣A.冪次(0);
	 * console.log(單位矩陣.數據); // [[1, 0], [0, 1]]
	 *
	 * @example
	 * // 計算矩陣的平方 (n = 2)
	 * let 矩陣A = new 矩陣([[2, 3], [4, 5]]);
	 * let 平方矩陣 = 矩陣A.冪次(2);
	 * console.log(平方矩陣.數據); // [[16, 21], [28, 37]]
	 *
	 * @example
	 * // 錯誤使用（負的冪次）
	 * let 矩陣A = new 矩陣([[2, 3], [4, 5]]);
	 * 矩陣A.冪次(-1); // 拋出錯誤：n 不可為負數
	 */
	冪次 (n) {
		if (n === 0) {
			return 矩陣.單位矩陣(this.橫列數量);
		}
		if (n === 1) {
			return this.複製();
		}

		let 回傳結果 = this.複製();
		for (let i = 2; i <= n; i++) {
			回傳結果 = 回傳結果.乘(this);
		}
		return 回傳結果;
	}

	/**
	 * 與另一個矩陣相加或加上一個數值，返回一個新的矩陣。
	 *
	 * 若參數為數值，將該數值加到矩陣的每個元素；若參數為矩陣，則執行矩陣的逐元素相加運算。
	 *
	 * @public
	 * @param {矩陣|number} 目標 可以是數值或矩陣。若為矩陣，則它的維度需與當前矩陣相同。
	 * @returns {矩陣} 返回相加運算後的新矩陣。
	 * @throws {型別錯誤} 當 `目標` 非數值或矩陣時，會拋出該錯誤。
	 * @throws {錯誤} 若 `目標` 為矩陣，但其維度與當前矩陣不匹配，會拋出錯誤。
	 *
	 * @example
	 * // 與數值相加
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 結果 = 矩陣A.加(10);
	 * console.log(結果.數據); // [[11, 12], [13, 14]]
	 *
	 * @example
	 * // 與另一個矩陣相加
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 矩陣B = new 矩陣([[5, 6], [7, 8]]);
	 * let 結果 = 矩陣A.加(矩陣B);
	 * console.log(結果.數據); // [[6, 8], [10, 12]]
	 *
	 * @example
	 * // 無效使用
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * 矩陣A.加("無效參數"); // 拋出型別錯誤
	 */
	加 (目標) {
		const 加上數值 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] + 目標;
		const 加上矩陣 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] + 目標[橫列編號][直行編號];
		return this.#加減運算(目標, 加上數值, 加上矩陣);
	}

	/**
	 * 計算並返回當前矩陣的反矩陣。
	 *
	 * 該方法僅適用於方陣，且矩陣的行列式必須不為 0，否則無法計算反矩陣。
	 *
	 * @public
	 * @returns {矩陣} 返回反矩陣的計算結果。
	 * @throws {Error} 當前矩陣不能計算反矩陣時拋出錯誤，可能為以下原因之一：
	 *  1. 矩陣的行數或列數為 0；
	 *  2. 矩陣不是方陣（行數不等於列數）；
	 *  3. 行列式為 0（矩陣不可逆）。
	 *
	 * @example
	 * // 計算 2x2 方陣的反矩陣
	 * let 矩陣A = new 矩陣([[4, 7], [2, 6]]);
	 * let 反矩陣A = 矩陣A.反矩陣();
	 * console.log(反矩陣A.數據);
	 * // [[0.6, -0.7], [-0.2, 0.4]]
	 *
	 * @example
	 * // 嘗試對行列式為 0 的矩陣計算反矩陣
	 * let 矩陣B = new 矩陣([[1, 2], [2, 4]]);
	 * 矩陣B.反矩陣(); // 拋出錯誤：因為行列式為零所以此矩陣沒有反矩陣
	 *
	 * @example
	 * // 嘗試對非方陣計算反矩陣
	 * let 矩陣C = new 矩陣([[1, 2, 3], [4, 5, 6]]);
	 * 矩陣C.反矩陣(); // 拋出錯誤：因為不是方陣所以此矩陣沒有反矩陣
	 */
	反矩陣 () {
		if (this.#直行數量 === 0 || this.#橫列數量 === 0) {
			throw new Error(錯誤訊息.矩陣.因為維度為0所以此矩陣沒有反矩陣);
		}
		if (this.特徵值 === 0) {
			throw new Error(錯誤訊息.矩陣.因為行列式為零所以此矩陣沒有反矩陣);
		}
		if (this.#直行數量 !== this.#橫列數量) {
			throw new Error(錯誤訊息.矩陣.因為不是方陣所以此矩陣沒有反矩陣);
		}

		const 單位矩陣 = 矩陣.單位矩陣(this.橫列數量);
		const 暫存矩陣 = this.合併直行(單位矩陣);

		return this.#高斯約旦消去法計算反矩陣(暫存矩陣);
	}

	/**
	 * 將當前矩陣與另一個矩陣按直行方向進行合併，返回新矩陣。
	 *
	 * 合併過程中，當前矩陣在左，參數矩陣 `m` 在右。兩矩陣的橫列數量必須一致，否則無法完成合併。
	 *
	 * @public
	 * @param {矩陣} m 要與當前矩陣合併的矩陣。其橫列數量需與當前矩陣相同。
	 * @returns {矩陣} 返回合併後的新矩陣。
	 * @throws {Error} 如果 `m` 的橫列數量與當前矩陣不一致，則拋出錯誤。
	 *
	 * @example
	 * // 合併兩個矩陣的直行
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 矩陣B = new 矩陣([[5], [6]]);
	 * let 合併矩陣 = 矩陣A.合併直行(矩陣B);
	 * console.log(合併矩陣.數據);
	 * // [[1, 2, 5], [3, 4, 6]]
	 *
	 * @example
	 * // 嘗試合併橫列數量不同的矩陣
	 * let 矩陣A = new 矩陣([[1, 2], [3, 4]]);
	 * let 矩陣B = new 矩陣([[5, 6]]);
	 * 矩陣A.合併直行(矩陣B); // 拋出錯誤：橫列數量不一致
	 */
	合併直行 (m) {
		const 新矩陣 = new 矩陣(this.橫列數量, this.直行數量 + m.直行數量);
		this.forEach((橫列, 橫列編號) => {
			新矩陣[橫列編號] = [...橫列, ...m[橫列編號]];
		});
		return 新矩陣;
	}

	/**
	 * 將矩陣的所有元素填入指定的數值，覆寫原有內容。
	 *
	 * 該方法會直接修改矩陣本身，並返回經過修改的矩陣，支援鏈式調用。
	 *
	 * @public
	 * @param {*} 值 要填入矩陣每個元素的值，可為任意類型（例如數字、字串等）。
	 * @returns {矩陣} 返回填滿指定值後的矩陣本身。
	 *
	 * @example
	 * // 將所有元素填入數值 2
	 * let 矩陣A = new 矩陣(2, 2).填滿(2);
	 * console.log(矩陣A.數據);
	 * // [[2, 2], [2, 2]]
	 *
	 * @example
	 * // 將所有元素填入字串 "測試"
	 * let 矩陣B = new 矩陣(3, 3).填滿("測試");
	 * console.log(矩陣B.數據);
	 * // [["測試", "測試", "測試"], ["測試", "測試", "測試"], ["測試", "測試", "測試"]]
	 */
	填滿 (值) {
		this.forEach(row => row.fill(值));
		return this;
	}

	/**
	 * 判斷當前矩陣是否為反對稱矩陣（Skew-Symmetric Matrix）。
	 *
	 * 反對稱矩陣的定義為：矩陣轉置後等於其本身的負矩陣，即對於所有元素需滿足條件 Aᵀ = -A。
	 *
	 * @public
	 * @returns {boolean} 如果當前矩陣是反對稱矩陣則返回 `true`，否則返回 `false`。
	 *
	 * @example
	 * // 判斷一個 2x2 矩陣是否為反對稱矩陣
	 * let 矩陣A = new 矩陣([[0, -2], [2, 0]]);
	 * console.log(矩陣A.是反對稱矩陣()); // true
	 *
	 * @example
	 * // 一個 2x2 矩陣不是反對稱矩陣
	 * let 矩陣B = new 矩陣([[1, 2], [3, 4]]);
	 * console.log(矩陣B.是反對稱矩陣()); // false
	 */
	是反對稱矩陣 () {
		return this.轉置矩陣().等於(this.乘(-1));
	}

	/**
	 * 判斷當前矩陣是否為對稱矩陣（Symmetric Matrix）。
	 *
	 * 對稱矩陣的定義為：矩陣轉置後與原矩陣相等，即對於所有元素需滿足條件 Aᵀ = A。
	 *
	 * @public
	 * @returns {boolean} 如果當前矩陣是對稱矩陣則返回 `true`，否則返回 `false`。
	 *
	 * @example
	 * // 判斷一個 2x2 矩陣是否為對稱矩陣
	 * let 矩陣A = new 矩陣([[1, 2], [2, 3]]);
	 * console.log(矩陣A.是對稱矩陣()); // true
	 *
	 * @example
	 * // 一個 2x2 矩陣不是對稱矩陣
	 * let 矩陣B = new 矩陣([[1, 0], [2, 3]]);
	 * console.log(矩陣B.是對稱矩陣()); // false
	 */
	是對稱矩陣 () {
		return this.轉置矩陣().等於(this);
	}

	/**
	 * 判斷當前矩陣是否為方塊矩陣（Square Matrix）。
	 *
	 * 方塊矩陣的定義為：矩陣的橫列數量與直行數量相等，即矩陣的行數與列數相同。
	 *
	 * @public
	 * @returns {boolean} 如果當前矩陣是方塊矩陣則返回 `true`，否則返回 `false`。
	 *
	 * @example
	 * // 判斷一個 3x3 矩陣是否為方塊矩陣
	 * let 矩陣A = new 矩陣(3, 3);
	 * console.log(矩陣A.是方塊矩陣()); // true
	 *
	 * @example
	 * // 一個 2x3 矩陣不是方塊矩陣
	 * let 矩陣B = new 矩陣(2, 3);
	 * console.log(矩陣B.是方塊矩陣()); // false
	 */
	是方塊矩陣 () {
		return this.#橫列數量 === this.#直行數量;
	}

	/**
	 * 取得指定橫列的值，並以向量形式回傳。
	 *
	 * 該方法根據提供的橫列編號，返回矩陣中該橫列的元素，回傳型別為向量。
	 *
	 * @public
	 * @param {number} 橫列編號 從 0 開始的橫列編號，表示要取得的橫列位置。
	 * @returns {向量} 包含指定橫列元素的向量。
	 *
	 * @example
	 * // 建立一個 2x2 的矩陣，並取得第 0 橫列的向量
	 * let 矩陣A = new 矩陣(2, 2);
	 * 矩陣A[0][0] = 1;
	 * 矩陣A[0][1] = 2;
	 * 矩陣A[1][0] = 3;
	 * 矩陣A[1][1] = 4;
	 *
	 * let 橫列向量 = 矩陣A.橫列(0);
	 * console.log(橫列向量); // [1, 2]
	 *
	 * @example
	 * // 如果橫列編號無效可能導致錯誤
	 * let 矩陣B = new 矩陣(2, 3);
	 * console.log(矩陣B.橫列(4)); // 拋出範圍錯誤（具體行為依實現而定）
	 */
	橫列 (橫列編號) {
		return new 向量(this[橫列編號]);
	}

	/**
	 * 對矩陣中的每一個元素執行指定的回呼函式。
	 *
	 * 該方法會遍歷矩陣中的所有元素，並將每個元素及其對應的橫列與直行編號作為參數，傳遞給回呼函式進行處理。
	 *
	 * @public
	 * @param {Function} 回呼函式 傳入的函式，會針對每個矩陣元素執行。回呼函式的簽名為：
	 * `(元素值: *, 橫列編號: number, 直行編號: number) => void`。
	 * - `元素值`：當前矩陣元素的值。
	 * - `橫列編號`：當前元素所在的橫列編號（從 0 開始）。
	 * - `直行編號`：當前元素所在的直行編號（從 0 開始）。
	 *
	 * @returns {矩陣} 當前矩陣本身，支援鏈式調用。
	 *
	 * @example
	 * // 將矩陣所有元素加倍
	 * let 矩陣A = new 矩陣(2, 2);
	 * 矩陣A[0][0] = 1;
	 * 矩陣A[0][1] = 2;
	 * 矩陣A[1][0] = 3;
	 * 矩陣A[1][1] = 4;
	 *
	 * 矩陣A.每一個元素((值, 橫列, 直行) => {
	 *   矩陣A[橫列][直行] = 值 * 2;
	 * });
	 * console.log(矩陣A);
	 * // [[2, 4], [6, 8]]
	 *
	 * @example
	 * // 計算元素總和
	 * let 總和 = 0;
	 * 矩陣A.每一個元素((值) => { 總和 += 值; });
	 * console.log(總和); // 20
	 */
	每一個元素 (回呼函式) {
		this.forEach((橫列, 橫列編號) =>
			橫列.forEach((元素, 直行編號) =>
				回呼函式(元素, 橫列編號, 直行編號)
			)
		);
		return this;
	}

	/**
	 * 遍歷矩陣中的每一橫列，並對每一橫列執行指定的回呼函式。
	 *
	 * 該方法會依序將矩陣中的每一橫列作為參數，傳遞給回呼函式進行處理。
	 *
	 * @public
	 * @param {Function} 回呼函式 傳入的函式，用於處理每一橫列。回呼函式的簽名為：
	 * `(橫列: Array, 橫列編號: number) => void`。
	 * - `橫列`：當前橫列的元素，型別為陣列。
	 * - `橫列編號`：當前橫列的編號（從 0 開始）。
	 *
	 * @returns {矩陣} 當前矩陣本身，支援鏈式調用。
	 *
	 * @example
	 * // 在一個 3x3 矩陣中，打印每一橫列
	 * let 矩陣A = new 矩陣(3, 3).填充(1);
	 * 矩陣A.每一個橫列((橫列, 橫列編號) => {
	 *   console.log(`橫列 ${橫列編號}:`, 橫列);
	 * });
	 * // 輸出：
	 * // 橫列 0: [1, 1, 1]
	 * // 橫列 1: [1, 1, 1]
	 * // 橫列 2: [1, 1, 1]
	 *
	 * @example
	 * // 計算每一橫列的總和值，並存入陣列
	 * let 總和 = [];
	 * 矩陣A.每一個橫列((橫列) => {
	 *   總和.push(橫列.reduce((累加, 值) => 累加 + 值, 0));
	 * });
	 * console.log(總和); // [3, 3, 3]
	 */
	每一個橫列 (回呼函式) {
		this.forEach((橫列, 橫列編號) => 回呼函式(橫列, 橫列編號));
		return this;
	}

	/**
	 * 遍歷矩陣中的每一個直行，並對每一個直行執行指定的回呼函式。
	 *
	 * 該方法會依序將矩陣中的每一個直行作為參數，傳遞給回呼函式進行處理。
	 *
	 * @public
	 * @param {Function} 回呼函式 傳入的函式，用於處理每一個直行。回呼函式的簽名為：
	 * `(直行: Array, 直行編號: number) => void`。
	 * - `直行`：當前直行的元素，型別為陣列。
	 * - `直行編號`：當前直行的編號（從 0 開始）。
	 *
	 * @returns {矩陣} 當前矩陣本身，支援鏈式調用。
	 *
	 * @example
	 * // 在一個 3x3 矩陣中，打印每一個直行
	 * let 矩陣A = new 矩陣(3, 3).填充(1);
	 * 矩陣A.每一個直行((直行, 直行編號) => {
	 *   console.log(`直行 ${直行編號}:`, 直行);
	 * });
	 * // 輸出：
	 * // 直行 0: [1, 1, 1]
	 * // 直行 1: [1, 1, 1]
	 * // 直行 2: [1, 1, 1]
	 *
	 * @example
	 * // 計算每一個直行的總和值，並存入陣列
	 * let 總和 = [];
	 * 矩陣A.每一個直行((直行) => {
	 *   總和.push(直行.reduce((累加, 值) => 累加 + 值, 0));
	 * });
	 * console.log(總和); // [3, 3, 3]
	 */
	每一個直行 (回呼函式) {
		this.#直行數量 && Array.from({ length: this.#直行數量 }, (_, 直行編號) =>
			回呼函式(this.直行(直行編號), 直行編號)
		);
		return this;
	}

	/**
	 * 清除矩陣中的所有數據，將矩陣重置為空。
	 *
	 * 該方法會移除矩陣中的所有元素，並將橫列數量與直行數量都重置為 0。
	 *
	 * @public
	 * @returns {矩陣} 當前矩陣本身，支援鏈式調用。
	 *
	 * @example
	 * // 清除一個 2x2 的矩陣
	 * let 矩陣A = new 矩陣(2, 2);
	 * 矩陣A.清除();
	 * console.log(矩陣A); // []
	 *
	 * @example
	 * // 鏈式調用清除方法
	 * let 矩陣B = new 矩陣(3, 3).填充(1).清除();
	 * console.log(矩陣B); // []
	 */
	清除 () {
		this.length = 0;
		this.#橫列數量 = 0;
		this.#直行數量 = 0;
		return this;
	}

	/**
	 * 將當前矩陣與另一個矩陣相減，或從矩陣中的每個元素減去一個數值。
	 *
	 * 該方法支援矩陣減法運算（相同位置元素相減），或者從矩陣中的每個元素減去一個數值，結果將是新的矩陣。
	 *
	 * @public
	 * @param {矩陣|number} 目標 欲減去的目標，可以是矩陣或固定的數值。
	 * - 如果是矩陣：必須與當前矩陣具有相同的維度（橫列數量與直行數量相等）。
	 * - 如果是數值：該數值將從矩陣中的每個元素中減去。
	 *
	 * @returns {矩陣} 包含相減結果的新矩陣。
	 *
	 * @throws {型別錯誤} 如果 `目標` 的類型不符合規範（既不是矩陣也不是數值），或者矩陣維度不匹配，則會拋出錯誤。
	 *
	 * @example
	 * // 矩陣減去另一個矩陣
	 * let 矩陣1 = new 矩陣([5, 6], [7, 8]);
	 * let 矩陣2 = new 矩陣([1, 2], [3, 4]);
	 * let 結果矩陣 = 矩陣1.減(矩陣2); // [[4, 4], [4, 4]]
	 * console.log(結果矩陣);
	 *
	 * @example
	 * // 矩陣減去一個數值
	 * let 矩陣3 = new 矩陣([5, 6], [7, 8]);
	 * let 結果矩陣2 = 矩陣3.減(2); // [[3, 4], [5, 6]]
	 * console.log(結果矩陣2);
	 *
	 * @example
	 * // 當矩陣維度不匹配時會拋出錯誤
	 * let 矩陣4 = new 矩陣([1, 2, 3], [4, 5, 6]);
	 * try {
	 *   矩陣1.減(矩陣4); // 錯誤：矩陣維度不匹配
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 */
	減 (目標) {
		const 減去數值 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] - 目標;
		const 減去矩陣 = (橫列編號, 直行編號, 新矩陣) => 新矩陣[橫列編號][直行編號] = this[橫列編號][直行編號] - 目標[橫列編號][直行編號];
		return this.#加減運算(目標, 減去數值, 減去矩陣);
	}

	/**
	 * 取得指定直行的元素，並以向量的形式回傳。
	 *
	 * 該方法會根據提供的直行編號，自矩陣中提取對應直行的所有元素，並將其組成為一個向量。
	 *
	 * @public
	 * @param {number} 直行編號 指定的直行索引，從 0 開始計數。
	 * - 必須是一個有效的數字，且在矩陣的直行範圍內。
	 *
	 * @returns {向量} 包含指定直行所有元素的向量。
	 *
	 * @throws {範圍錯誤} 如果提供的 `直行編號` 超出矩陣範圍，則會拋出錯誤。
	 *
	 * @example
	 * // 取得矩陣中的第一直行
	 * let 矩陣1 = new 矩陣([1, 2], [3, 4]);
	 * let 第一直行 = 矩陣1.直行(0); // [1, 3]
	 * console.log(第一直行);
	 *
	 * @example
	 * // 取得矩陣中的第二直行
	 * let 第二直行 = 矩陣1.直行(1); // [2, 4]
	 * console.log(第二直行);
	 *
	 * @example
	 * // 嘗試使用無效的直行編號（範圍外）
	 * try {
	 *   let 無效直行 = 矩陣1.直行(2);
	 * } catch (e) {
	 *   console.error(e.message); // 直行編號超出範圍
	 * }
	 */
	直行 (直行編號) {
		return this.map(橫列 => 橫列[直行編號]);
	}

	/**
	 * 判斷當前矩陣是否與目標矩陣相等。
	 *
	 * 當兩個矩陣的維度（橫列數量與直行數量）相同，且對應位置的每個元素皆相等時，則判定為相等。
	 *
	 * @public
	 * @param {矩陣} 目標 用於比較的目標矩陣。
	 *
	 * @returns {boolean} 如果兩個矩陣的維度相同，且每一個元素相等則回傳 `true`，否則回傳 `false`。
	 *
	 * @throws {型別錯誤} 如果傳入的參數 `目標` 不是矩陣類型，則拋出錯誤。
	 *
	 * @example
	 * // 比較兩個相等的矩陣
	 * let 矩陣1 = new 矩陣([1, 2], [3, 4]);
	 * let 矩陣2 = new 矩陣([1, 2], [3, 4]);
	 * console.log(矩陣1.等於(矩陣2)); // true
	 *
	 * @example
	 * // 比較兩個不同的矩陣
	 * let 矩陣3 = new 矩陣([5, 6], [7, 8]);
	 * console.log(矩陣1.等於(矩陣3)); // false
	 *
	 * @example
	 * // 當比較對象不是矩陣時拋出例外
	 * try {
	 *   console.log(矩陣1.等於([1, 2, 3])); // 錯誤：參數值必須是矩陣
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 */
	等於 (目標) {
		if (!(目標 instanceof 矩陣)) {
			throw new 型別錯誤(錯誤訊息.矩陣.參數值必須是矩陣);
		}

		if (
			this.#橫列數量 !== 目標.橫列數量 ||
			this.#直行數量 !== 目標.直行數量
		) {
			return false;
		}

		return this.flat().every((值, 索引) => 值 === 目標.flat()[索引]);
	}

	/**
	 * 計算矩陣中所有元素的總和。
	 *
	 * 該方法會遍歷矩陣中所有的元素，並根據提供的初始值進行累加。支援數值型、字串型等元素類型，也可透過初始值指定累加的起點類型。
	 *
	 * @public
	 * @param {*} [初始值=0] 指定累加的初始值，預設為 `0`。當矩陣包含字串元素時，建議將初始值設為空字串 `""` 來正確處理。
	 *
	 * @returns {*} 矩陣中所有元素的累加結果，其類型取決於初始值與矩陣元素的類型。
	 *
	 * @example
	 * // 計算數值矩陣的總和
	 * let 矩陣1 = new 矩陣(2, 2);
	 * 矩陣1[0][0] = 1;
	 * 矩陣1[0][1] = 2;
	 * 矩陣1[1][0] = 3;
	 * 矩陣1[1][1] = 4;
	 * console.log(矩陣1.總和()); // 10
	 *
	 * @example
	 * // 計算字串矩陣的連接結果
	 * let 矩陣2 = new 矩陣(['a', 'b'], ['c', 'd']);
	 * console.log(矩陣2.總和('')); // "abcd"
	 *
	 * @example
	 * // 使用不同的初始值進行累加
	 * let 矩陣3 = new 矩陣([1, 2], [3, 4]);
	 * console.log(矩陣3.總和(10)); // 20
	 *
	 * @example
	 * // 矩陣完全由字串組成，初始值為空字串
	 * let 矩陣4 = new 矩陣(['hello', 'world'], ['foo', 'bar']);
	 * console.log(矩陣4.總和('')); // "helloworldfoobar"
	 */
	總和 (初始值 = 0) {
		return this.flat().reduce((加總, 元素) => 加總 + 元素, 初始值);
	}

	/**
	 * 複製當前矩陣，生成一個與之相同的新矩陣。
	 *
	 * 該方法會創建一個該矩陣的完整副本，包含所有數據內容但內存地址不同，確保修改新矩陣時不會影響原始矩陣。
	 *
	 * @public
	 * @returns {矩陣} 一個與當前矩陣完全相同的新矩陣實例。
	 *
	 * @example
	 * // 複製矩陣
	 * let 原始矩陣 = new 矩陣([1, 2], [3, 4]);
	 * let 新矩陣 = 原始矩陣.複製();
	 * console.log(新矩陣); // [[1, 2], [3, 4]]
	 *
	 * @example
	 * // 修改複製後的矩陣不影響原始矩陣
	 * 新矩陣[0][0] = 5;
	 * console.log(原始矩陣); // [[1, 2], [3, 4]]
	 * console.log(新矩陣);  // [[5, 2], [3, 4]]
	 */
	複製 () {
		return this.複製範圍(0, 0, this.#橫列數量, this.#直行數量);
	}

	/**
	 * 複製矩陣中指定範圍的子矩陣。
	 *
	 * 該方法允許從當前矩陣中提取指定範圍的子矩陣，基於起始位置與橫列及直行數量進行複製並返回新矩陣。
	 *
	 * @public
	 * @param {number} 起始橫列編號 子矩陣的起始橫列索引（從 0 開始）。
	 * @param {number} 起始直行編號 子矩陣的起始直行索引（從 0 開始）。
	 * @param {number} 橫列數量 要複製的橫列數量，必須大於或等於 0。
	 * @param {number} 直行數量 要複製的直行數量，必須大於或等於 0。
	 *
	 * @returns {矩陣} 包含指定範圍內所有元素的新矩陣。
	 *
	 * @throws {範圍錯誤}
	 * - 當 `起始橫列編號` 或 `起始直行編號` 超出矩陣範圍時。
	 * - 當 `橫列數量` 或 `直行數量` 小於 0 時。
	 * - 當所指定的範圍超出矩陣的邊界時（例如：`起始橫列編號 + 橫列數量` 超出矩陣的橫列範圍）。
	 *
	 * @example
	 * // 複製子矩陣
	 * let 矩陣1 = new 矩陣([1, 2, 3], [4, 5, 6], [7, 8, 9]);
	 * let 子矩陣 = 矩陣1.複製範圍(0, 0, 2, 2);
	 * console.log(子矩陣); // [[1, 2], [4, 5]]
	 *
	 * @example
	 * // 超出範圍範例
	 * try {
	 *   let 無效子矩陣 = 矩陣1.複製範圍(2, 2, 2, 2);
	 * } catch (e) {
	 *   console.error(e.message); // 直行數量超出範圍
	 * }
	 *
	 * @example
	 * // 設定無效的數量
	 * try {
	 *   let 無效矩陣 = 矩陣1.複製範圍(0, 0, -1, 2);
	 * } catch (e) {
	 *   console.error(e.message); // 橫列數量必須大於零
	 * }
	 */
	複製範圍 (起始橫列編號, 起始直行編號, 橫列數量, 直行數量) {
		this.#橫列編號必須在範圍內(起始橫列編號);
		this.#直行編號必須在範圍內(起始直行編號);

		if (橫列數量 <= 0 || 直行數量 <= 0) {
			throw new Error('橫列數量和直行數量必須大於零');
		}
		if (起始橫列編號 + 橫列數量 > this.#橫列數量 || 起始直行編號 + 直行數量 > this.#直行數量) {
			throw new Error('範圍超出矩陣邊界');
		}

		const 回傳結果 = new 矩陣(橫列數量, 直行數量);

		回傳結果.forEach((row, 橫列索引) => {
			row.forEach((_, 直行索引) => {
				row[直行索引] = this[起始橫列編號 + 橫列索引][起始直行編號 + 直行索引];
			});
		});

		return 回傳結果;
	}

	/**
	 * 設定矩陣中指定橫列的值。
	 *
	 * 這個方法允許將一個向量或陣列的值賦予矩陣中指定的橫列，會對每個直行位置進行逐一更新。
	 *
	 * @public
	 * @param {number} 橫列編號 要設定的橫列索引（從 0 開始）。
	 * @param {向量|Array} 值 要賦予橫列的新值，必須是向量或陣列，且其元素數量需與矩陣的直行數量相同。
	 *
	 * @returns {矩陣} 修改後的矩陣（原地修改）。
	 *
	 * @throws {範圍錯誤} 如果 `橫列編號` 超出矩陣的橫列範圍，則拋出例外。
	 * @throws {型別錯誤} 如果 `值` 不是向量或陣列，則拋出例外。
	 * @throws {錯誤} 如果 `值` 的長度與矩陣的直行數量不匹配，則拋出錯誤。
	 *
	 * @example
	 * // 設定矩陣橫列的值
	 * let 矩陣1 = new 矩陣(2, 3); // 初始矩陣 [[0, 0, 0], [0, 0, 0]]
	 * 矩陣1.設定橫列(0, [1, 2, 3]);
	 * console.log(矩陣1); // [[1, 2, 3], [0, 0, 0]]
	 *
	 * @example
	 * // 使用向量設定橫列
	 * let 向量1 = new 向量(3);
	 * 向量1[0] = 4;
	 * 向量1[1] = 5;
	 * 向量1[2] = 6;
	 * 矩陣1.設定橫列(1, 向量1);
	 * console.log(矩陣1); // [[1, 2, 3], [4, 5, 6]]
	 *
	 * @example
	 * // 異常情況：橫列索引超出範圍
	 * try {
	 *   矩陣1.設定橫列(2, [7, 8, 9]); // 錯誤：橫列編號超出範圍
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 *
	 * @example
	 * // 異常情況：值的長度與矩陣不匹配
	 * try {
	 *   矩陣1.設定橫列(0, [10, 11]); // 錯誤：值的長度與直行數量不匹配
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 */
	設定橫列 (橫列編號, 值) {
		this.#橫列編號必須在範圍內(橫列編號);
		this.#參數值必須是向量或矩陣(值);

		this[橫列編號] = Array.from({ length: this.#直行數量 }, (_, 直行編號) => 值[直行編號]);

		return this;
	}

	/**
	 * 設定矩陣中指定直行的值。
	 *
	 * 這個方法允許將一個向量或陣列的值賦予矩陣中指定的直行，會對每個橫列位置進行逐一更新。
	 *
	 * @public
	 * @param {number} 直行編號 要設定的直行索引（從 0 開始）。
	 * @param {向量|Array} 值 要賦予直行的新值，必須是向量或陣列，且其元素數量需與矩陣的橫列數量相同。
	 *
	 * @returns {矩陣} 修改後的矩陣（原地修改）。
	 *
	 * @throws {範圍錯誤} 如果 `直行編號` 超出矩陣的直行範圍，則拋出例外。
	 * @throws {型別錯誤} 如果 `值` 不是向量或陣列，則拋出例外。
	 * @throws {錯誤} 如果 `值` 的長度與矩陣的橫列數量不匹配，則拋出錯誤。
	 *
	 * @example
	 * // 設定矩陣直行的值
	 * let 矩陣1 = new 矩陣(3, 2); // 初始矩陣 [[0, 0], [0, 0], [0, 0]]
	 * 矩陣1.設定直行(0, [1, 2, 3]);
	 * console.log(矩陣1); // [[1, 0], [2, 0], [3, 0]]
	 *
	 * @example
	 * // 使用向量設定直行
	 * let 向量1 = new 向量(3);
	 * 向量1[0] = 4;
	 * 向量1[1] = 5;
	 * 向量1[2] = 6;
	 * 矩陣1.設定直行(1, 向量1);
	 * console.log(矩陣1); // [[1, 4], [2, 5], [3, 6]]
	 *
	 * @example
	 * // 異常情況：直行索引超出範圍
	 * try {
	 *   矩陣1.設定直行(2, [7, 8, 9]); // 錯誤：直行編號超出範圍
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 *
	 * @example
	 * // 異常情況：值的長度與矩陣不匹配
	 * try {
	 *   矩陣1.設定直行(0, [10, 11]); // 錯誤：值的長度與橫列數量不匹配
	 * } catch (e) {
	 *   console.error(e.message);
	 * }
	 */
	設定直行 (直行編號, 值) {
		this.#直行編號必須在範圍內(直行編號);
		this.#參數值必須是向量或矩陣(值);

		this.forEach((row, 橫列編號) => {
			row[直行編號] = 值[橫列編號];
		});

		return this;
	}

	/**
	 * 重新設定矩陣的維度，清除所有現有的元素並以預設值填滿新矩陣。
	 *
	 * 此方法允許修改矩陣的橫列數量和直行數量，會移除所有現有數據，並使用矩陣的預設值填充新的結構。
	 *
	 * @public
	 * @param {number} 新的橫列數量 新矩陣的橫列數量，必須為非負整數。
	 * @param {number} 新的直行數量 新矩陣的直行數量，必須為非負整數。
	 *
	 * @returns {矩陣} 返回修改後的矩陣本身（原地修改）。
	 *
	 * @throws {錯誤} 如果 `新的橫列數量` 或 `新的直行數量` 為負值，則拋出例外。
	 *
	 * @example
	 * // 設定矩陣的新維度並填滿
	 * let m = new 矩陣(2, 2).填滿(2); // 初始矩陣 [[2, 2], [2, 2]]
	 * m.設定維度(3, 3); // 設定維度為 3x3，並清除資料後填滿預設值
	 * console.log(m); // Example output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
	 *
	 * @example
	 * // 使用設定維度與自定義初始化值
	 * let m = new 矩陣(2, 3).填滿(1);
	 * m.設定維度(2, 2);
	 * console.log(m); // [[0, 0], [0, 0]]
	 *
	 * @example
	 * // 異常情況：試圖使用負值設定維度
	 * try {
	 *   let m = new 矩陣(2, 2);
	 *   m.設定維度(-1, 3); // 錯誤：橫列數量為負值
	 * } catch (e) {
	 *   console.error(e.message); // "橫列數量或直行數量不得為負值"
	 * }
	 */
	設定維度 (新的橫列數量, 新的直行數量) {
		this.#橫列數量 = 新的橫列數量;
		this.#直行數量 = 新的直行數量;
		this.length = 0; // 清空現有元素
		this.push(...Array.from({ length: this.#橫列數量 },
			() => Array(this.#直行數量).fill(this.#預設值)
		));
		return this;
	}

	/**
	 * 將矩陣轉換為包含其結構及數值的字串表示。
	 *
	 * 此方法會以易讀的格式將矩陣的內容轉換為字串，每個橫列會另起一行，每個元素之間帶有適當的間隔，
	 * 並自動處理可能存在的浮點精度誤差，將非常小的數值（接近 0）顯示為 0。
	 *
	 * @public
	 * @returns {string} 矩陣的字串表示，格式為多行字串（帶有縮排和換行）。
	 *
	 * @example
	 * // 將矩陣轉為字串
	 * let 矩陣1 = new 矩陣(2, 2).填滿([1.0000000001, 2, 3.00000000001, 4]);
	 * console.log(矩陣1.轉為字串());
	 * // 輸出:
	 * // [
	 * //   [ 1  2 ]
	 * //   [ 3  4 ]
	 * // ]
	 *
	 * @example
	 * // 處理接近 0 的小值
	 * let 矩陣2 = new 矩陣(2, 2).填滿([1e-10, 0, 2.5, 3e-12]);
	 * console.log(矩陣2.轉為字串());
	 * // 輸出:
	 * // [
	 * //   [ 0  0 ]
	 * //   [ 2.5  0 ]
	 * // ]
	 */
	轉為字串 () {
		let 回傳結果 = '[\r\n';
		this.forEach((row) => {
			回傳結果 += '  [' +
				row.reduce((acc, curr) => acc + ' ' +
					型別.修正精確度誤差((型別.是很小的值(curr) ? 0 : curr)) + ' ', '');
			回傳結果 += ']\r\n';
		});
		回傳結果 += ']\r\n';
		return 回傳結果;
	}

	/**
	 * 回傳矩陣的轉置矩陣。
	 *
	 * 轉置矩陣是將原矩陣的橫列與直行位置對調後的結果。例如，橫列元素將成為直行元素，直行元素將成為橫列元素。
	 *
	 * @public
	 * @returns {矩陣} 一個新的轉置後的矩陣。
	 *
	 * @throws {Error} 如果矩陣的維度為 0（即沒有橫列或直行），則拋出錯誤。
	 *
	 * @example
	 * // 將一個 2x3 的矩陣轉置
	 * const m = new 矩陣([1, 2, 3], [4, 5, 6]);
	 * const t = m.轉置矩陣();
	 * console.log(t); // [[1, 4], [2, 5], [3, 6]]
	 *
	 * @example
	 * // 異常情況：空矩陣無法轉置
	 * try {
	 *   const m = new 矩陣(0, 0);
	 *   const t = m.轉置矩陣();
	 * } catch (e) {
	 *   console.error(e.message); // "矩陣維度為 0 不可執行轉置操作"
	 * }
	 */
	轉置矩陣 () {
		if (!this.#直行數量 || !this.#橫列數量) {
			throw new Error(錯誤訊息.矩陣.矩陣維度為0不可轉置);
		}
		const 回傳結果 = new 矩陣(this.#直行數量, this.#橫列數量);
		回傳結果.forEach((_, 橫列編號) => {
			回傳結果[橫列編號] = this.map((行) => 行[橫列編號]);
		});
		return 回傳結果;
	}
};
