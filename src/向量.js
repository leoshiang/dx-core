const 型別 = require('./型別');
const { 型別錯誤, 參數錯誤, } = require('./例外');
const 位元陣列 = require('./位元陣列');
const 錯誤訊息 = require('./錯誤訊息');

/**
 * 回呼函式
 * @callback 向量回呼函式
 * @param {*} 數值
 * @param {number} 索引
 */

/**
 * 向量類別
 *
 * @class 向量
 * @extends Array
 * @classdesc
 * 此類別表示一個向量，基於原生 JavaScript 的 `Array` 類別進行擴展，
 * 可用於數學計算、向量操作或作為多維數據處理中的基本結構。
 * 支援所有 Array 的方法，並可進一步擴展向量的操作能力。
 *
 * @example
 * // 範例 1: 創建一個空的向量
 * const vector1 = new 向量();
 * console.log(vector1); // 輸出: []
 *
 * @example
 * // 範例 2: 創建一個具有初始值的向量
 * const vector2 = new 向量(1, 2, 3);
 * console.log(vector2); // 輸出: [1, 2, 3]
 *
 * @example
 * // 範例 3: 使用 Array 的方法操作向量
 * const vector3 = new 向量(5, 6, 7);
 * vector3.push(8);
 * console.log(vector3); // 輸出: [5, 6, 7, 8]
 *
 * @example
 * // 範例 4: 為向量添加自定義操作
 * 向量.prototype.長度 = function () {
 *   return Math.sqrt(this.reduce((sum, val) => sum + val ** 2, 0));
 * };
 * const vector4 = new 向量(3, 4);
 * console.log(vector4.長度()); // 返回: 5 (向量模長)
 */
module.exports = class 向量 extends Array {

	/**
	 * 向量類別的建構函式。
	 *
	 * @constructor
	 * @param {Array|number} [初始值=0] - 初始值，能接受一個數字或陣列：
	 *    - 如果是數字，將用該數字初始化向量的長度，並以 0 填充內容。
	 *    - 如果是陣列，將使用該陣列的元素進行初始化。
	 * @throws {參數錯誤} - 如果提供的數字初始值小於 0，將拋出錯誤。
	 *
	 * @example
	 * // 使用數字初始化一個長度為 5 的向量
	 * const 向量1 = new 向量(5);
	 * console.log(向量1); // [0, 0, 0, 0, 0]
	 *
	 * @example
	 * // 使用陣列初始化一個向量
	 * const 向量2 = new 向量([1, 2, 3]);
	 * console.log(向量2); // [1, 2, 3]
	 *
	 * @example
	 * // 使用內嵌的單元素陣列初始化一個向量
	 * const 向量3 = new 向量([[42]]);
	 * console.log(向量3); // [42]
	 *
	 * @example
	 * // 如果提供的數字初始值為負數，將拋出參數錯誤
	 * try {
	 *   const 向量4 = new 向量(-1);
	 * } catch (錯誤) {
	 *   console.error(錯誤); // 參數錯誤: 長度必須大於等於零
	 * }
	 */
	constructor (初始值 = 0) {
		const 參數陣列 = Array.from(arguments);

		if (參數陣列.length === 1) {
			const 第一個參數 = 參數陣列[0];

			if (型別.是陣列(第一個參數) && 第一個參數.length === 1) {
				super();
				this.push(第一個參數[0]);
				return;
			}

			if (型別.是數值(第一個參數)) {
				if (第一個參數 < 0) {
					throw new 參數錯誤(錯誤訊息.向量.長度必須大於等於零);
				}
				super(第一個參數);
				this.fill(0);
				return;
			}
		}

		// 使用展開語法展開陣列參數
		const 展開的參數 = 參數陣列.flatMap(b => (型別.是陣列(b) ? b : [b]));
		super(...展開的參數);
	}

	/**
	 * 計算向量的範數（長度）。
	 *
	 * @returns {number} - 向量的範數，根據歐幾里得距離計算公式取得。
	 *
	 * @example
	 * const 向量 = [3, 4];
	 * const 範數 = 向量.範數; // 範數為 5，因為 Math.sqrt(3^2 + 4^2) = 5
	 */
	get 範數 () {
		return Math.sqrt(this.reduce((sum, value) => sum + value * value, 0));
	}

	/**
	 * 私有方法：尋找最後一個符合條件的項目。
	 *
	 * 此方法會遍歷當前陣列中的所有項目，根據提供的條件函式判斷哪些項目符合條件。
	 * 如果某些項目被排除項目位元陣列標記為 `true`，這些項目將會被忽略。
	 *
	 * @param {function(*, *): boolean} 條件 - 條件函式，用來比較項目是否符合條件。
	 *    函式參數：
	 *    - 第一個參數：目前的陣列項目。
	 *    - 第二個參數：目前已找到的符合條件的項目的值。
	 *    回傳值：
	 *    - 若符合條件，應回傳 `true`。
	 * @param {位元陣列} 排除項目 - 排除位元陣列，標記需要忽略的索引位置。
	 *    如果對應索引值為 `true`，則該項目會被排除在檢查之外。
	 * @returns {{索引: number, 值: *}} - 結果物件包含以下兩個屬性：
	 *    - `索引`：最後一個符合條件的項目的索引，若沒有符合條件的項目則為 -1。
	 *    - `值`：該項目的值，若沒有符合條件的項目則為 `undefined`。
	 *
	 * @example
	 * // 假設我們有一個陣列
	 * const 向量 = [1, 3, 5, 7, 9];
	 * const 排除項目 = new 位元陣列([false, false, true, false, false]); // 排除第三個項目 (index = 2)
	 *
	 * // 尋找最大值的項目
	 * const 結果 = 向量.#尋找最後一個符合條件的項目((目前項目, 目前最大值) => 目前項目 > 目前最大值, 排除項目);
	 * console.log(結果);
	 * // 輸出：{ 索引: 4, 值: 9 }，因為 9 是剩下項目中最大的一個。
	 *
	 * @example
	 * // 如果陣列為空或條件為 null
	 * const 空向量 = [];
	 * const 空結果 = 空向量.#尋找最後一個符合條件的項目(() => true, null);
	 * console.log(空結果);
	 * // 輸出：{ 索引: -1, 值: undefined }
	 */
	#尋找最後一個符合條件的項目 (條件, 排除項目) {
		this.#排除項目的型別必須是位元陣列(排除項目);
		let 回傳結果 = {
			索引: -1,
			值: undefined
		};
		if (this.length === 0 || !條件) {
			return 回傳結果;
		}
		回傳結果.索引 = 0;
		回傳結果.值 = this[0];
		let 目前索引 = 1;
		while (目前索引 <= this.length - 1) {
			if (排除項目 && 排除項目.狀態(目前索引)) {
				目前索引++;
				continue;
			}
			let 目前項目 = this[目前索引];
			if (條件(目前項目, 回傳結果.值)) {
				回傳結果 = {
					索引: 目前索引,
					值: 目前項目,
				};
			}
			目前索引++;
		}
		return 回傳結果;
	}

	/**
	 * 私有方法：尋找第一個符合條件的項目。
	 *
	 * 此方法會從陣列中逐一檢查項目，根據提供的目標值與條件函式，返回第一個符合條件的項目。
	 * 若指定排除項目，排除的索引將不進行判斷。
	 *
	 * @param {*} 目標值 - 用於條件判斷的目標值，會作為參數傳遞給條件函式。
	 * @param {位元陣列} 排除項目 - 排除指定索引的位元陣列，若對應索引為 `true`，該索引的項目會被忽略。
	 * @param {function(*, *): boolean} 條件 - 回呼函式，用於判斷是否符合條件。
	 *    函式包含：
	 *    - 第一個參數：當前陣列中的項目。
	 *    - 第二個參數：提供的目標值。
	 *    回傳值：
	 *    - 如果符合條件，應回傳 `true`。
	 * @returns {{索引: number, 值: *}} - 結果物件包含：
	 *    - `索引`：第一個符合條件的項目的索引，若沒有符合條件項目則為 -1。
	 *    - `值`：第一個符合條件的項目的值，若沒有符合條件則為 `null`。
	 *
	 * @example
	 * // 假設我們有一個陣列
	 * const 向量 = [10, 20, 30, 40, 50];
	 * const 排除項目 = new 位元陣列([false, true, false, false, false]); // 排除第二項 (20)
	 *
	 * // 尋找第一個大於 25 的項目
	 * const 結果 = 向量.#尋找第一個符合條件的項目(25, 排除項目, (目前項目, 目標值) => 目前項目 > 目標值);
	 * console.log(結果);
	 * // 輸出：{ 索引: 2, 值: 30 }，因為 30 是第一個大於 25 的數字，且未被排除。
	 *
	 * @example
	 * // 如果陣列中所有項目都不符合條件
	 * const 空結果 = 向量.#尋找第一個符合條件的項目(60, null, (目前項目, 目標值) => 目前項目 > 目標值);
	 * console.log(空結果);
	 * // 輸出：{ 索引: -1, 值: null }
	 */
	#尋找第一個符合條件的項目 (目標值, 排除項目, 條件) {
		this.#排除項目的型別必須是位元陣列(排除項目);
		型別.回呼函式的型別必須是函式(條件);

		for (let 目前索引 = 0; 目前索引 < this.length; 目前索引++) {
			if (排除項目?.狀態(目前索引)) {
				continue;
			}

			const 目前項目 = this[目前索引];
			if (條件(目前項目, 目標值)) {
				return {
					索引: 目前索引,
					值: 目前項目,
				};
			}
		}

		return {
			索引: -1,
			值: null,
		};
	}

	/**
	 * 私有方法：驗證排除項目是否為位元陣列。
	 *
	 * 此方法用於檢查 `排除項目` 是否為有效的 `位元陣列`，若不是則拋出型別錯誤。
	 *
	 * @param {*} 排除項目 - 要檢查的排除項目實例，可以為 `null` 或 `undefined`。
	 *    - 若為有效的 `位元陣列`，此方法將通過驗證。
	 *    - 若類型不符合（且不為空值），將拋出型別錯誤。
	 *
	 * @throws {型別錯誤} - 當 `排除項目` 非空且不是 `位元陣列` 的實例時，拋出型別錯誤，並提示對應的錯誤訊息。
	 *
	 * @example
	 * // 正確用法：傳入位元陣列
	 * const 排除項目 = new 位元陣列([true, false, true]);
	 * this.#排除項目的型別必須是位元陣列(排除項目); // 通過驗證
	 *
	 * @example
	 * // 錯誤用法：非位元陣列類型
	 * const 非位元陣列 = [true, false, true];
	 * try {
	 *     this.#排除項目的型別必須是位元陣列(非位元陣列);
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：錯誤訊息.向量.參數excludedElements型別必須是位元陣列
	 * }
	 */
	#排除項目的型別必須是位元陣列 (排除項目) {
		if (排除項目 && !(排除項目 instanceof 位元陣列)) {
			throw new 型別錯誤(錯誤訊息.向量.參數excludedElements型別必須是位元陣列);
		}
	}

	/**
	 * 私有方法：檢查向量是否為三維。
	 *
	 * @param {向量|Array} 向量 - 要檢查的向量。
	 * @throws {Error} - 若向量的長度不是 3，則拋出錯誤。
	 * @private
	 */
	#檢查三維向量 (向量) {
		if (!Array.isArray(向量) || 向量.length !== 3) {
			throw new Error(錯誤訊息.向量.外積僅能對三維向量做運算);
		}
	}

	/**
	 * 私有方法：檢查兩個向量是否具有相同的維度。
	 *
	 * @param {向量} 來源 - 要檢查的來源向量。
	 * @throws {參數錯誤} - 若來源向量的長度與當前向量不相同，拋出錯誤。
	 * @private
	 */
	#檢查向量維度相同 (來源) {
		if (來源.length !== this.length) {
			throw new 參數錯誤(錯誤訊息.向量.參數來源的長度必須相同);
		}
	}

	/**
	 * 私有方法：檢查排除項目是否為位元陣列。
	 *
	 * @param {位元陣列|null} 排除項目 - 要檢查的排除項目。
	 * @throws {型別錯誤} - 若排除項目不是位元陣列類型，則拋出錯誤。
	 * @private
	 */
	#檢查排除項目的型別 (排除項目) {
		if (排除項目 !== null && !(排除項目 instanceof 位元陣列)) {
			throw new 型別錯誤('排除項目必須是位元陣列或 null');
		}
	}

	/**
	 * 驗證索引是否在有效範圍內。
	 *
	 * 此方法用於檢查傳入的索引是否在陣列的有效範圍內（`0 <= 索引 < this.length`）。
	 * 若索引無效（超出範圍），則拋出一個錯誤。
	 *
	 * @param {number} index - 要檢查的索引值。
	 *    - 必須是大於等於 0 並且小於此陣列長度的有效索引。
	 *
	 * @throws {Error} - 當索引小於 0 或大於等於陣列長度時，拋出錯誤。
	 *    錯誤訊息為 `錯誤訊息.向量.索引超出範圍`。
	 *
	 * @example
	 * // 正確用法
	 * const 向量 = [10, 20, 30];
	 * 向量.#索引必須在範圍內(1); // 通過驗證（索引 1 在範圍內）
	 *
	 * @example
	 * // 錯誤用法
	 * try {
	 *     向量.#索引必須在範圍內(-1); // 無效索引
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：錯誤訊息.向量.索引超出範圍
	 * }
	 *
	 * try {
	 *     向量.#索引必須在範圍內(3); // 無效索引，等於陣列長度
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：錯誤訊息.向量.索引超出範圍
	 * }
	 */
	#索引必須在範圍內 (index) {
		if (index < 0 || index >= this.length) {
			throw new Error(錯誤訊息.向量.索引超出範圍);
		}
	}

	/**
	 * 將向量中的每個元素乘以指定的倍數，並返回新的向量。
	 *
	 * 此方法不會變更原向量，而是返回一個新的向量，其每一個元素為原向量中對應元素與指定倍數的乘積。
	 *
	 * @param {number} 倍數 - 要乘以的數值。
	 *    - 必須為有效的數值，否則將拋出型別錯誤。
	 *
	 * @returns {向量} - 返回一個新的向量，其元素為原向量每個元素與倍數的乘積。
	 *
	 * @throws {型別錯誤} - 當 `倍數` 不是有效數值時，拋出型別錯誤。
	 *    錯誤訊息為 `錯誤訊息.傳入的參數應為數值`。
	 *
	 * @example
	 * // 正確用法：對向量進行倍率運算
	 * const 原向量 = new 向量([1, 2, 3]);
	 * const 結果向量 = 原向量.乘(3);
	 * console.log(結果向量); // 輸出：[3, 6, 9]
	 *
	 * @example
	 * // 錯誤用法：傳入非數值型參數
	 * try {
	 *     const 原向量 = new 向量([1, 2, 3]);
	 *     原向量.乘("文字"); // 傳入無效倍數
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：錯誤訊息.傳入的參數應為數值
	 * }
	 */
	乘 (倍數) {
		if (型別.不是數值(倍數)) {
			throw new 型別錯誤(錯誤訊息.傳入的參數應為數值);
		}

		return new 向量(this.map(元素 => 元素 * 倍數));
	}

	/**
	 * 交換向量中兩個指定索引的元素位置。
	 *
	 * 此方法會交換向量中指定索引 `a` 和 `b` 的元素，並返回當前向量對象。
	 *
	 * @param {number} a - 第一個元素的索引。
	 *    - 必須在向量的有效範圍內，否則將拋出錯誤。
	 * @param {number} b - 第二個元素的索引。
	 *    - 必須在向量的有效範圍內，否則將拋出錯誤。
	 *
	 * @returns {向量} - 返回被修改後的當前向量對象。
	 *
	 * @throws {錯誤} - 若索引 `a` 或 `b` 超出向量範圍，將拋出錯誤。
	 *
	 * @example
	 * // 正確用法：交換索引 0 和 2 的元素
	 * const 向量 = new 向量([1, 2, 3]);
	 * 向量.交換(0, 2);
	 * console.log(向量); // 輸出：[3, 2, 1]
	 *
	 * @example
	 * // 錯誤用法：索引超出範圍
	 * try {
	 *     const 向量 = new 向量([1, 2, 3]);
	 *     向量.交換(0, 5); // 索引 5 超出範圍
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：錯誤訊息.向量.索引超出範圍
	 * }
	 */
	交換 (a, b) {
		this.#索引必須在範圍內(a);
		this.#索引必須在範圍內(b);
		let temp = this[a];
		this[a] = this[b];
		this[b] = temp;
		return this;
	}

	/**
	 * 計算當前向量與另一個向量的內積。
	 *
	 * 內積是將兩個向量中對應位置的元素相乘並求和的結果，該方法僅適用於向量長度相等的情況。
	 *
	 * @param {向量} 另一個向量 - 與當前向量進行內積計算的另一個向量。
	 *    - 向量的長度必須與當前向量相同。
	 * @returns {number} - 返回計算後的數值內積。
	 * @throws {錯誤} - 如果另一個向量的長度與當前向量的長度不同，則拋出錯誤。
	 *
	 * @example
	 * // 計算兩個向量的內積
	 * const 向量1 = new 向量([1, 2, 3]);
	 * const 向量2 = new 向量([4, 5, 6]);
	 * const 內積結果 = 向量1.內積(向量2);
	 * console.log(內積結果); // 輸出：32 (1*4 + 2*5 + 3*6)
	 *
	 * @example
	 * // 當向量長度不同時拋出錯誤
	 * try {
	 *     const 向量1 = new 向量([1, 2, 3]);
	 *     const 向量2 = new 向量([4, 5]);
	 *     向量1.內積(向量2);
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：向量維度相同才能計算內積
	 * }
	 */
	內積 (另一個向量) {
		this.#檢查向量維度相同(另一個向量);

		return 另一個向量.reduce(
			(累加器, 當前值, 索引) => 累加器 + 當前值 * this[索引],
			0 // 初始化內積值為 0
		);
	}

	/**
	 * 對向量進行加法運算。
	 *
	 * 可用於兩個向量相加，或者向量中每個元素加上一個標量值（數字）。
	 *
	 * @param {向量|number|null|undefined} 來源 - 加法的來源，可以是另一個向量或一個標量值（數字）。
	 *    - 若為向量，長度必須與當前向量一致。
	 *    - 若為 `null` 或 `undefined`，將返回當前向量的複製。
	 * @returns {向量} - 返回新的向量，表示加法的結果。
	 * @throws {參數錯誤} - 若來源為向量但長度不同，則拋出錯誤。
	 *
	 * @example
	 * // 與另一個向量相加
	 * const 向量1 = new 向量([1, 2, 3]);
	 * const 向量2 = new 向量([4, 5, 6]);
	 * const 結果 = 向量1.加(向量2);
	 * console.log(結果); // 輸出：[5, 7, 9]
	 *
	 * @example
	 * // 每個元素加上一個數字
	 * const 向量 = new 向量([1, 2, 3]);
	 * const 結果 = 向量.加(5);
	 * console.log(結果); // 輸出：[6, 7, 8]
	 *
	 * @example
	 * // 傳入 null 或 undefined，返回向量的複製
	 * const 向量 = new 向量([1, 2, 3]);
	 * const 複製向量 = 向量.加(null);
	 * console.log(複製向量); // 輸出：[1, 2, 3]
	 *
	 * @example
	 * // 向量長度不一致時拋出錯誤
	 * try {
	 *     const 向量1 = new 向量([1, 2, 3]);
	 *     const 向量2 = new 向量([4, 5]);
	 *     向量1.加(向量2);
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：參數來源的長度必須相同
	 * }
	 */
	加 (來源) {
		if (!來源) {
			return this.複製();
		}

		// 檢查來源是否為向量，且長度相同
		if (來源 instanceof 向量) {
			this.#檢查向量維度相同(來源);
		}

		const 回傳結果 = new 向量(this.length);
		const 是向量 = 來源 instanceof 向量;

		// 通用的加法邏輯
		for (let i = 0; i < this.length; i++) {
			回傳結果[i] = this[i] + (是向量 ? 來源[i] : 來源);
		}

		return 回傳結果;
	}

	/**
	 * 計算向量中所有元素的加總，並支援選擇性排除指定項目。
	 *
	 * @param {位元陣列|null} 排除項目 - 指定需排除的元素索引，類型必須為位元陣列或 `null`。
	 *    - 當為位元陣列時，其中 `true` 表示對應索引的向量值將被排除。
	 *    - 當為 `null` 時，將計算全部向量元素的加總。
	 * @returns {number} - 返回加總結果，若無任何計算值則返回 `undefined`。
	 * @throws {型別錯誤} - 若排除項目的型別不是位元陣列，則拋出錯誤。
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3, 4]);
	 * const 排除 = new 位元陣列([false, true, false, true]); // 排除索引 1 和 3
	 * console.log(向量.加總(排除)); // 輸出：4 (1 + 3)
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3, 4]);
	 * console.log(向量.加總()); // 輸出：10 (1 + 2 + 3 + 4)
	 */
	加總 (排除項目 = null) {
		this.#排除項目的型別必須是位元陣列(排除項目);

		let 回傳結果 = undefined;

		for (let 索引 = 0; 索引 < this.length; 索引++) {
			if (排除項目 && 排除項目.狀態(索引)) {
				continue;
			}

			if (回傳結果 === undefined) {
				回傳結果 = this[索引]; // 設定初始值
			} else {
				回傳結果 += this[索引]; // 累加值
			}
		}

		return 回傳結果;
	}

	/**
	 * 計算當前向量與另一個向量的外積（Cross Product）。
	 *
	 * 外積僅適用於三維向量，結果也是一個三維向量。
	 *
	 * @param {向量|Array} 另一個向量 - 用於計算外積的另一個三維向量。
	 * @returns {向量} - 新的向量，代表外積計算結果。
	 * @throws {Error} - 若任意一個向量的長度不是 3，則拋出錯誤。
	 *
	 * @example
	 * const 向量1 = new 向量([1, 0, 0]);
	 * const 向量2 = new 向量([0, 1, 0]);
	 * const 結果 = 向量1.外積(向量2);
	 * console.log(結果); // 輸出：[0, 0, 1]
	 *
	 * @example
	 * // 當向量長度不是 3 時，拋出錯誤
	 * try {
	 *     const 向量1 = new 向量([1, 2]);
	 *     const 向量2 = new 向量([3, 4, 5]);
	 *     向量1.外積(向量2);
	 * } catch (錯誤) {
	 *     console.error(錯誤.message);
	 *     // 輸出：外積僅能對三維向量做運算
	 * }
	 */
	外積 (另一個向量) {
		this.#檢查三維向量(this);
		this.#檢查三維向量(另一個向量);

		const [x1, y1, z1] = this;
		const [x2, y2, z2] = 另一個向量;

		return new 向量(
			y1 * z2 - z1 * y2,
			z1 * x2 - x1 * z2,
			x1 * y2 - y1 * x2
		);
	}

	/**
	 * 判斷是否為零向量。
	 *
	 * 零向量是指所有元素皆為數字零的向量。
	 *
	 * @returns {boolean} - 若向量中所有元素均為零，則返回 `true`，否則返回 `false`。
	 *
	 * @example
	 * const 向量 = new 向量([0, 0, 0]);
	 * console.log(向量.是零向量()); // 輸出：true
	 *
	 * @example
	 * const 向量 = new 向量([0, 1, 0]);
	 * console.log(向量.是零向量()); // 輸出：false
	 */
	是零向量 () {
		return this.every(元素 => 型別.兩個數值相等(元素, 0));
	}

	/**
	 * 使用回呼函式更新向量中的每個項目。
	 *
	 * 如果指定的項目的索引在排除項目中設定為 `true`，則該項目將被忽略。
	 *
	 * @param {function} 回呼函式 - 用於更新每個項目的函式，接收兩個參數 `(當前值, 索引)`，並返回新值。
	 * @param {位元陣列|null} 排除項目 - 用於指示要排除哪些項目的位元陣列 (`true` 表示排除相應的索引)。
	 *    - 默認為 `null`，不排除任何項目。
	 * @returns {向量} - 返回更新後的向量本身。
	 * @throws {型別錯誤} - 若排除項目的型別不是位元陣列，則拋出錯誤。
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3]);
	 * const 新向量 = 向量.更新全部((值, 索引) => 值 * 2); // 所有項目乘以 2
	 * console.log(新向量); // 輸出：[2, 4, 6]
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3]);
	 * const 排除 = new 位元陣列([false, true, false]); // 排除索引 1
	 * 向量.更新全部((值, 索引) => 值 + 索引, 排除); // 更新時排除索引 1
	 * console.log(向量); // 輸出：[1, 2, 5]
	 */
	更新全部 (回呼函式, 排除項目 = null) {
		this.#檢查排除項目的型別(排除項目);

		this.forEach((值, 索引) => {
			if (!(排除項目 && 排除項目.狀態(索引))) {
				this[索引] = 回呼函式(值, 索引);
			}
		});

		return this;
	}

	/**
	 * 尋找向量中的最大值。
	 *
	 * 可傳入排除項目，使被排除的索引不參與比較。
	 *
	 * @param {位元陣列|null} 排除項目 - 用於排除指定索引的位元陣列，`true` 表示該索引將被忽略。
	 *    - 默認為 `null`，表示不排除任何項目。
	 * @returns {{值: number, 索引: number}} - 返回一個對象，包含最大值及其對應索引。
	 *
	 * @example
	 * const 向量 = new 向量([1, 3, 2, 5]);
	 * const 結果 = 向量.最大值();
	 * console.log(結果); // 輸出：{ 值: 5, 索引: 3 }
	 *
	 * @example
	 * const 向量 = new 向量([1, 3, 2, 5]);
	 * const 排除 = new 位元陣列([false, false, true, false]); // 排除索引 2
	 * const 結果 = 向量.最大值(排除);
	 * console.log(結果); // 輸出：{ 值: 5, 索引: 3 }
	 */
	最大值 (排除項目 = null) {
		const 條件 = (目前的項目, 已知最大的項目) => 目前的項目 > 已知最大的項目;
		return this.#尋找最後一個符合條件的項目(條件, 排除項目);
	}

	/**
	 * 尋找向量中的最小值。
	 *
	 * 可傳入排除項目，使被排除的索引不參與比較。
	 *
	 * @param {位元陣列|null} 排除項目 - 用於排除指定索引的位元陣列，`true` 表示該索引將被忽略。
	 *    - 默認為 `null`，表示不排除任何項目。
	 * @returns {{值: number, 索引: number}} - 返回一個對象，包含最小值及其對應的索引。
	 *
	 * @example
	 * const 向量 = new 向量([1, 3, 2, 0]);
	 * const 結果 = 向量.最小值();
	 * console.log(結果); // 輸出：{ 值: 0, 索引: 3 }
	 *
	 * @example
	 * const 向量 = new 向量([1, 3, 2, 0]);
	 * const 排除 = new 位元陣列([false, true, false, false]); // 排除索引 1
	 * const 結果 = 向量.最小值(排除);
	 * console.log(結果); // 輸出：{ 值: 0, 索引: 3 }
	 */
	最小值 (排除項目 = null) {
		const 條件 = (目前的項目, 已知最小的項目) => 目前的項目 < 已知最小的項目;
		return this.#尋找最後一個符合條件的項目(條件, 排除項目);
	}

	/**
	 * 檢查是否有相鄰的兩個項目。
	 *
	 * 相鄰的定義為，項目 `a` 的下一個項目是否等於 `b`。
	 *
	 * @param {*} a - 第一個項目。
	 * @param {*} b - 要檢查是否相鄰的第二個項目。
	 * @returns {boolean} - 如果找到相鄰的 `a` 和 `b`，返回 `true`；否則返回 `false`。
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3, 4]);
	 * const 結果 = 向量.有相鄰的(2, 3);
	 * console.log(結果); // 輸出：true
	 *
	 * @example
	 * const 向量 = new 向量([1, 2, 3, 4]);
	 * const 結果 = 向量.有相鄰的(3, 1);
	 * console.log(結果); // 輸出：false
	 */
	有相鄰的 (a, b) {
		if (this.length <= 1) {
			return false;
		}

		const 索引 = this.indexOf(a);
		if (索引 === -1 || 索引 >= this.length - 1) {
			return false;
		}

		const 下一個項目 = this[索引 + 1];
		return 型別.是數值(a) && 型別.是數值(b)
			? 型別.兩個數值相等(下一個項目, b)
			: 下一個項目 === b;
	}

	/**
	 * 第一個大於目標值的項目。
	 * @param {number} 目標值
	 * @param {位元陣列} 排除項目
	 * @return {{值: number, 索引: number}|{值: null, 索引: number}}
	 * @throws {型別錯誤} 如果有傳入排除項目，但型別不是位元陣列，會拋出此例外。
	 * @example
	 *  const v1 = new 向量([1, 2, 3, 4])
	 *  console.log(v1.第一個大於的項目(2)) // {索引: 2,值: 3})
	 *
	 *  const v2 = new 向量([1, 2, 3, 4])
	 *  const 排除項目 = new 位元陣列('0010')
	 *  console.log(v2.第一個大於(2, 排除項目)) // {索引: 2,值: 3})
	 */
	第一個大於 (目標值, 排除項目 = null) {
		const 條件 = (目前的項目, 目標值) => 目前的項目 > 目標值;
		return this.#尋找第一個符合條件的項目(目標值, 排除項目, 條件);
	}

	/**
	 * 第一個小於目標值的項目。
	 * @param {number} 目標值
	 * @param {位元陣列} 排除項目
	 * @return {{值: number, 索引: number}|{值: null, 索引: number}}
	 * @throws {型別錯誤} 如果有傳入排除項目，但型別不是位元陣列，會拋出此例外。
	 * @example
	 *  const v1 = new 向量([4, 3, 2, 1])
	 *  console.log(v1.第一個小於(4)) // {索引: 1,值: 3})
	 *
	 *  const v2 = new 向量([4, 3, 2, 1])
	 *  const 排除項目 = new 位元陣列('0010')
	 *  console.log(v2.第一個小於(4, 排除項目)) // {索引: 2,值: 3})
	 */
	第一個小於 (目標值, 排除項目 = null) {
		const 條件 = (目前的項目, 目標值) => 目前的項目 < 目標值;
		return this.#尋找第一個符合條件的項目(目標值, 排除項目, 條件);
	}

	/**
	 * 檢查當前向量是否與另一個向量相等。
	 *
	 * 當兩個數值的差異小於 `0.00000001` 時，視為相等。
	 *
	 * @param {向量|Array} 另一個向量 - 要比較的另一個向量或陣列。
	 * @returns {boolean} - 若兩向量相等則返回 `true`，否則返回 `false`。
	 * @throws {型別錯誤} - 當參數不是向量或陣列時，拋出型別錯誤。
	 *
	 * @example
	 * const 向量1 = new 向量([1, 2, 3]);
	 * const 向量2 = new 向量([1, 2, 3]);
	 * console.log(向量1.等於(向量2)); // 輸出：true
	 *
	 * @example
	 * const 向量1 = new 向量([1, 2, 3]);
	 * const 向量2 = [1, 2, 3];
	 * console.log(向量1.等於(向量2)); // 輸出：true
	 *
	 * @example
	 * const 向量1 = new 向量([1, 2, 3]);
	 * const 向量2 = new 向量([1, 2]);
	 * console.log(向量1.等於(向量2)); // 輸出：false
	 */
	等於 (另一個向量) {
		// 驗證參數型別
		if (!(另一個向量 instanceof 向量 || 型別.是陣列(另一個向量))) {
			throw new 型別錯誤(錯誤訊息.向量.參數另一個向量的型別必須是向量或陣列);
		}

		// 長度不同直接返回 false
		if (this.length !== 另一個向量.length) {
			return false;
		}

		// 比較兩個向量的每個元素
		return this.every((值, 索引) => 型別.兩個數值相等(值, 另一個向量[索引]));
	}

	/**
	 * 複製當前向量並返回一個全新的向量實例。
	 *
	 * @returns {向量} - 新的向量，包含與當前向量相同的元素。
	 *
	 * @example
	 * const 原向量 = new 向量([1, 2, 3]);
	 * const 新向量 = 原向量.複製();
	 * console.log(新向量); // 輸出：向量 [1, 2, 3]
	 * console.log(原向量 === 新向量); // 輸出：false（引用不同）
	 */
	複製 () {
		return new this.constructor(this);
	}

	/**
	 * 迭代向量內的所有項目，跳過指定的排除項目（若有）。
	 *
	 * @param {向量回呼函式} 回呼函式 - 對每個項目執行的回呼函式，格式為 `(值, 索引) => void`。
	 * @param {位元陣列|null} [排除項目=null] - 用於指定應排除的索引，`true` 表示該索引將被跳過。
	 * @returns {向量} - 返回當前向量自身，用於支援鏈式調用。
	 * @throws {型別錯誤} - 如果回呼函式不是函式或排除項目的型別不正確，拋出型別錯誤。
	 *
	 * @example
	 * const 向量1 = new 向量([1, 2, 3, 4]);
	 * 向量1.迭代((值, 索引) => console.log(`值: ${值}, 索引: ${索引}`));
	 *
	 * @example
	 * const 排除 = new 位元陣列([false, true, false, true]);
	 * const 向量2 = new 向量([1, 2, 3, 4]);
	 * 向量2.迭代((值, 索引) => console.log(`值: ${值}, 索引: ${索引}`), 排除);
	 */
	迭代 (回呼函式, 排除項目 = null) {
		// 驗證回呼函式型別
		型別.回呼函式的型別必須是函式(回呼函式);

		// 若有排除項目，驗證其型別
		if (排除項目) {
			this.#排除項目的型別必須是位元陣列(排除項目);
		}

		// 遍歷向量，跳過排除項目
		this.forEach((值, 索引) => {
			if (!排除項目 || !排除項目.狀態(索引)) {
				回呼函式(值, 索引);
			}
		});

		// 返回自身以支援鏈式調用
		return this;
	}

	/**
	 * 將新項目附加到當前向量的末尾，並返回新的向量。
	 *
	 * @param {...*} 要附加的項目 - 可以是單一數值、陣列或其他向量。
	 * @returns {向量} - 返回包含附加項目的新向量。
	 *
	 * @example
	 * const 原向量 = new 向量([1, 2, 3]);
	 * const 新向量 = 原向量.附加(4, 5, [6, 7]);
	 * console.log(新向量); // 輸出：向量 [1, 2, 3, 4, 5, 6, 7]
	 *
	 * @example
	 * const 原向量 = new 向量([1, 2]);
	 * const 其他向量 = new 向量([3, 4]);
	 * const 合併後 = 原向量.附加(其他向量);
	 * console.log(合併後); // 輸出：向量 [1, 2, 3, 4]
	 */
	附加 (...要附加的項目) {
		const 新向量 = this.複製();

		要附加的項目.flat().forEach(項目 => 新向量.push(項目));

		return 新向量;
	}
};
