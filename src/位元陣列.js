const 字串工具 = require('./字串工具');
const 型別 = require('./型別');
const 錯誤訊息 = require('./錯誤訊息');
const {
	二進位字串內容錯誤,
	索引超出範圍錯誤,
	型別錯誤,
	參數錯誤,
} = require('./例外');

/**
 * @class
 * @classdesc 位元陣列適合用來記錄大量的 boolean 值，其記憶體使用量為用單一 boolean(4 bytes)的 1/24。
 */

module.exports = class 位元陣列 {
	#一頁可紀錄的位元數 = 24;
	#四位元組 = [
		'0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
		'1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];
	#數量 = 0;
	#頁面 = [];

	/**
	 * @constructor
	 * @param {number|string} 初始值 如果傳入數值，代表要存放幾個位元。如果是字串，則會將字串視為二進位字串去解析。
	 * @throws {型別錯誤} 如果初始值不是大於零的數值會拋出此例外。
	 * @example
	 * let 位元陣列1 = new 位元陣列('01010101')
	 * let 位元陣列2 = new 位元陣列(3)
	 */
	constructor (初始值) {
		if (型別.是字串(初始值)) {
			this.解析二進位字串(初始值);
		} else if (型別.是數值(初始值)) {
			this.#設定位元數量(初始值);
		} else {
			this.#設定位元數量(0);
		}
	}

	/**
	 * 取得位元數目。
	 * @returns {number}
	 * @example
	 * let 位元陣列 = new 位元陣列('01010101')
	 * console.log(位元陣列.數量())
	 */
	get 數量 () {
		return this.#數量;
	}

	/**
	 * 頁面數目。一頁可以放 24 個位元，若有 25 個位元，頁面數目應為 2。
	 * @returns {number}
	 * @example
	 * let 位元陣列 = new 位元陣列('01010101')
	 * console.log(位元陣列.頁面數量())
	 */
	get 頁面數量 () {
		return this.#頁面.length;
	}

	/**
	 * 根據位元編號計算它落在哪一個頁面。
	 * @param {number} 位元編號 位元編號必須 >= 0 且小於位元數。
	 * @return {number} 頁面編號，從 0 開始。
	 */
	#取得頁面編號 (位元編號) {
		return Math.floor(位元編號 / this.#一頁可紀錄的位元數);
	}

	/**
	 * 確保字串只有 0 和 1 的字元。
	 * @param {string} 字串
	 * @throws {二進位字串內容錯誤} 如果字串有不是 0 或 1 的字元，便會拋出此例外。
	 */
	#確保二進位字串只有0和1的字元 (字串) {
		if (!字串) {
			return;
		}
		for (let i = 0; i < 字串.length; i++) {
			if (字串[i] !== '0' && 字串[i] !== '1') {
				throw new 二進位字串內容錯誤;
			}
		}
	}

	/**
	 * 確保位元編號在範圍內。
	 * @param {number} 位元編號 位元編號必須 >= 0 且小於位元數
	 * @throws {型別錯誤} 如果位元編號不是數值會拋出此例外。
	 * @throws {索引超出範圍錯誤} 如果位元編號超出範圍會拋出此例外。
	 */
	#確定位元編號在範圍內 (位元編號) {
		if (型別.不是數值(位元編號)) {
			throw new 型別錯誤(錯誤訊息.位元陣列.位元編號必須是數值);
		}
		if (位元編號 < 0 || 位元編號 >= this.#數量) {
			throw new 索引超出範圍錯誤(`位元編號必須在(0,${this.#數量 - 1})之間。`);
		}
	}

	/**
	 * 計算要幾個頁面才能儲存需要的位元數。
	 * @param {number} 位元數量
	 * @return {number} 頁面數。
	 */
	#計算需要的頁面數量 (位元數量) {
		return Math.floor((位元數量 + this.#一頁可紀錄的位元數 - 1) / this.#一頁可紀錄的位元數);
	}

	/**
	 * 設定這個位元陣列要儲存的位元數。
	 * @param {number} 新數量
	 * @throws {型別錯誤} 如位元數不是大於零的數值會拋出此例外。
	 */
	#設定位元數量 (新數量) {
		if (型別.不是數值(新數量) || 新數量 < 0) {
			throw new 型別錯誤(錯誤訊息.位元陣列.位元數必須是大於零的數值);
		}
		this.#頁面.length = this.#計算需要的頁面數量(新數量);
		this.#頁面.fill(0);
		this.#數量 = 新數量;
	}

	/**
	 * 與傳入的位元陣列做 and 運算，並回傳新位元陣列。
	 * @param {位元陣列} 參數另一個向量的長度必須相同
	 * @throws {參數錯誤} 當對象的位元數不同時會拋出此例外。
	 * @return {位元陣列} 新位元陣列。
	 */
	and (參數另一個向量的長度必須相同) {
		if (參數另一個向量的長度必須相同.數量 !== this.#數量) {
			throw new 參數錯誤(錯誤訊息.位元陣列.參數的位元數不同無法進行運算);
		}
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map((x, index) => x & 參數另一個向量的長度必須相同.#頁面[index]);
		return 回傳結果;
	}

	/**
	 * 位元陣列做 not 運算，並回傳新位元陣列。
	 * @return {位元陣列} 新位元陣列。
	 */
	not () {
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map(x => ~x);
		return 回傳結果;
	}

	/**
	 * 與傳入的位元陣列做 or 運算，並回傳新位元陣列。
	 * @param {位元陣列} 參數另一個向量的長度必須相同
	 * @throws {參數錯誤} 當對象的位元數不同時會拋出此例外。
	 * @return {位元陣列} 新位元陣列。
	 */
	or (參數另一個向量的長度必須相同) {
		if (參數另一個向量的長度必須相同.數量 !== this.#數量) {
			throw new 參數錯誤(錯誤訊息.位元陣列.參數的位元數不同無法進行運算);
		}
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map((x, index) => x | 參數另一個向量的長度必須相同.#頁面[index]);
		return 回傳結果;
	}

	/**
	 * 與傳入的位元陣列做 xor 運算，並回傳新位元陣列 。
	 * @param {位元陣列} 參數另一個向量的長度必須相同
	 * @throws {參數錯誤} 當對象的位元數不同時會拋出此例外。
	 * @return {位元陣列} 新位元陣列。
	 */
	xor (參數另一個向量的長度必須相同) {
		if (參數另一個向量的長度必須相同.數量 !== this.#數量) {
			throw new 參數錯誤(錯誤訊息.位元陣列.參數的位元數不同無法進行運算);
		}
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map((x, index) => x ^ 參數另一個向量的長度必須相同.#頁面[index]);
		return 回傳結果;
	}

	/**
	 * 取得編號位置的位元狀態。
	 * @param {number} 位元編號 位元編號必須 >= 0 且小於位元數
	 * @return {boolean} 如果編號位置的位元是1則回傳 true，否則回傳 false。
	 * @throws {型別錯誤} 如果位元編號不是數字會拋出此例外。
	 * @throws {索引超出範圍錯誤} 如果位元編號超出範圍會拋出此例外。
	 */
	狀態 (位元編號) {
		this.#確定位元編號在範圍內(位元編號);
		let 頁面 = this.#頁面[this.#取得頁面編號(位元編號)];
		return (頁面 & (1 << 位元編號 % this.#一頁可紀錄的位元數)) !== 0;
	}

	/**
	 * 複製自己到新的位元陣列。
	 * @return {位元陣列}
	 */
	複製 () {
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = [].concat(this.#頁面);
		return 回傳結果;
	}

	/**
	 * 解析二進位字串。
	 * @param {string} 二進位字串 二進位字串。如果有空白字元，它們會被移除，不影響解析。
	 * @return {位元陣列}
	 * @example
	 * const 位元陣列= new 位元陣列(0)
	 * 位元陣列.解析字串('10101010')
	 */
	解析二進位字串 (二進位字串) {
		const 移除空白之後的二進位字串 = 字串工具.移除空白字元(二進位字串);
		this.#確保二進位字串只有0和1的字元(移除空白之後的二進位字串);
		let 結束位置 = 移除空白之後的二進位字串.length;
		let 起始位置 = 結束位置 - Math.min(this.#一頁可紀錄的位元數, 移除空白之後的二進位字串.length);
		this.#設定位元數量(移除空白之後的二進位字串.length);
		let 頁面編號 = 0;
		while (頁面編號 < this.#頁面.length) {
			let part = 移除空白之後的二進位字串.substring(起始位置, 結束位置);
			this.#頁面[頁面編號] = parseInt(part, 2);
			結束位置 -= this.#一頁可紀錄的位元數;
			起始位置 -= this.#一頁可紀錄的位元數;
			頁面編號++;
		}
		return this;
	}

	/**
	 * 設定所有位元的狀態為 true 或 false。
	 * @param {boolean} 狀態 true 或 false。
	 * @return {位元陣列}
	 * @example
	 * const 位元陣列= new 位元陣列(25)
	 * 位元陣列.設定全部(true) // 1111111111111111111111111
	 */
	設定全部狀態 (狀態) {
		this.#頁面 = this.#頁面.map(() => 狀態 ? 0xFFFFFF : 0);
		return this;
	}

	/**
	 * 設定位元編號的狀態。
	 * @param {number} 位元編號 位元編號必須 >= 0 且小於位元數
	 * @param {boolean} 狀態 true or false。
	 * @return {位元陣列}
	 * @example
	 * const 位元陣列= new 位元陣列(24)
	 * 位元陣列.設定(1, true)
	 * 位元陣列.設定(2, false)
	 */
	設定狀態 (位元編號, 狀態) {
		this.#確定位元編號在範圍內(位元編號);
		let 分頁編號 = this.#取得頁面編號(位元編號);
		const 位元遮罩 = 1 << (位元編號 % this.#一頁可紀錄的位元數);
		if (狀態) {
			this.#頁面[分頁編號] |= 位元遮罩;
		} else {
			this.#頁面[分頁編號] &= ~位元遮罩;
		}
		return this;
	}

	/**
	 * 將整個位元陣列用 01 的字串表示。
	 * @return {string} 01 字串。
	 */
	轉為二進位字串 () {
		let 回傳結果 = '';
		let 四位元組的數量 = this.#一頁可紀錄的位元數 / 4;
		this.#頁面.forEach((x => {
			for (let i = 0; i < 四位元組的數量; i++) {
				回傳結果 = this.#四位元組[(x >> (i * 4)) & 0x0000000F] + 回傳結果;
			}
		}));
		return 回傳結果.slice(回傳結果.length - this.#數量)
	}
}
