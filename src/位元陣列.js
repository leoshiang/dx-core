import 字串工具 from './字串工具.js';
import 型別 from './型別.js';
import 錯誤訊息 from './錯誤訊息.js';
import {
	二進位字串內容錯誤,
	索引超出範圍錯誤,
	型別錯誤,
	參數錯誤,
} from './例外.js';

/**
 * 位元陣列 (BitArray)
 *
 * @class 位元陣列
 * @classdesc
 * 此類別作為一個位元級別的數據結構，用於管理和操作二進位數據。
 * 位元陣列支援靈活的位元記錄方式，並提供根據字串或數值初始化的功能。
 */
export default class 位元陣列 {
	static 四位元組 = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
		'1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];

	#一頁可記錄的位元數 = 24;
	#數量 = 0;
	#頁面 = [];

	constructor (初始值) {
		if (型別.是字串(初始值)) {
			this.解析二進位字串(初始值);
		} else if (型別.是數字(初始值)) {
			this.#設定位元數量(初始值);
		} else {
			this.#設定位元數量(0);
		}
	}

	get 數量 () {
		return this.#數量;
	}

	get 頁面數量 () {
		return this.#頁面.length;
	}

	#取得頁面編號 (位元編號) {
		return Math.floor(位元編號 / this.#一頁可記錄的位元數);
	}

	#執行邏輯運算 (另一個向量, 運算符) {
		this.#驗證(另一個向量.數量 === this.數量, 參數錯誤, '位元數不同無法進行運算');

		const 二元運算 = {
			'and': (a, b) => a & b,
			'or': (a, b) => a | b,
			'xor': (a, b) => a ^ b
		}[運算符];

		const 結果 = new 位元陣列(this.數量);
		結果.#頁面 = this.#頁面.map((x, index) => 二元運算(x, 另一個向量.#頁面[index]));
		return 結果;
	}

	#確保二進位字串只有0和1的字元 (字串) {
		if (!字串) {
			return;
		}
		for (let i = 0; i < 字串.length; i++) {
			if (字串[i] !== '0' && 字串[i] !== '1') {
				throw new 二進位字串內容錯誤();
			}
		}
	}

	#確定位元編號在範圍內 (位元編號) {
		this.#驗證(
			型別.是數字(位元編號),
			型別錯誤,
			錯誤訊息.位元陣列.位元編號必須是數值
		);

		this.#驗證(
			位元編號 >= 0 && 位元編號 < this.#數量,
			索引超出範圍錯誤,
			`位元編號必須在(0,${this.#數量 - 1})之間。`
		);
	}

	#計算需要的頁面數量 (位元數量) {
		return Math.floor((位元數量 + this.#一頁可記錄的位元數 - 1) / this.#一頁可記錄的位元數);
	}

	#設定位元數量 (新數量) {
		this.#驗證(
			型別.是數字(新數量) && 新數量 >= 0,
			型別錯誤,
			錯誤訊息.位元陣列.位元數必須是大於零的數值
		);
		this.#頁面.length = this.#計算需要的頁面數量(新數量);
		this.#頁面.fill(0);
		this.#數量 = 新數量;
	}

	#驗證 (條件, 錯誤類別, 錯誤訊息) {
		if (!條件) {
			throw new 錯誤類別(錯誤訊息);
		}
	}

	and (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'and');
	}

	not () {
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map(x => ~x);
		return 回傳結果;
	}

	or (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'or');
	}

	xor (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'xor');
	}

	狀態 (位元編號) {
		this.#確定位元編號在範圍內(位元編號);

		const 頁面索引 = this.#取得頁面編號(位元編號);
		const 位元遮罩 = 1 << (位元編號 % this.#一頁可記錄的位元數);

		return (this.#頁面[頁面索引] & 位元遮罩) !== 0;
	}

	複製 () {
		const 新位元陣列 = new 位元陣列(this.數量);
		新位元陣列.#頁面 = this.#頁面.slice();
		return 新位元陣列;
	}

	解析二進位字串 (二進位字串) {
		const 移除空白之後的二進位字串 = 字串工具.移除空白字元(二進位字串);
		this.#確保二進位字串只有0和1的字元(移除空白之後的二進位字串);
		let 結束位置 = 移除空白之後的二進位字串.length;
		let 起始位置 = 結束位置 - Math.min(this.#一頁可記錄的位元數, 移除空白之後的二進位字串.length);
		this.#設定位元數量(移除空白之後的二進位字串.length);
		let 頁面編號 = 0;
		while (頁面編號 < this.#頁面.length) {
			let part = 移除空白之後的二進位字串.substring(起始位置, 結束位置);
			this.#頁面[頁面編號] = parseInt(part, 2);
			結束位置 -= this.#一頁可記錄的位元數;
			起始位置 -= this.#一頁可記錄的位元數;
			頁面編號++;
		}
		return this;
	}

	設定全部狀態 (狀態) {
		const 填充值 = 狀態 ? 0xFFFFFF : 0;

		this.#頁面.fill(填充值);

		return this;
	}

	設定狀態 (位元編號, 狀態) {
		this.#確定位元編號在範圍內(位元編號);

		const 分頁編號 = this.#取得頁面編號(位元編號);
		const 位元遮罩 = 1 << (位元編號 % this.#一頁可記錄的位元數);

		this.#頁面[分頁編號] = 狀態
			? this.#頁面[分頁編號] | 位元遮罩
			: this.#頁面[分頁編號] & ~位元遮罩;

		return this;
	}

	轉為二進位字串 () {
		const 四位元組的數量 = this.#一頁可記錄的位元數 / 4;
		const 結果 = this.#頁面.flatMap(x =>
			Array.from(
				{ length: 四位元組的數量 },
				(_, i) => 位元陣列.四位元組[(x >> (i * 4)) & 0x0000000F]
			)
		);
		return 結果.reverse().join('').slice(-this.#數量);
	}
}

/**
 * 位元陣列 (BitArray)
 *
 * @class 位元陣列
 * @classdesc
 * 此類別作為一個位元級別的數據結構，用於管理和操作二進位數據。
 * 位元陣列支援靈活的位元記錄方式，並提供根據字串或數值初始化的功能。
 * 可用於存放大量位元數據，同時支援分頁管理和位元運算等功能。
 *
 * @example
 * // 範例 1: 初始化一個空的位元陣列
 * const bitArray1 = new 位元陣列();
 * console.log(bitArray1.數量); // 輸出: 0
 *
 * @example
 * // 範例 2: 根據指定的二進位字串初始化
 * const bitArray2 = new 位元陣列("10101");
 * console.log(bitArray2.數量); // 輸出: 5
 *
 * @example
 * // 範例 3: 使用數值初始化 (位元數量)
 * const bitArray3 = new 位元陣列(16);
 * console.log(bitArray3.數量); // 輸出: 16
 *
 * @example
 * // 範例 4: 執行位元操作
 * bitArray3.設置位元(0, 1); // 設置第 0 位為 1
 * console.log(bitArray3.取得位元(0)); // 輸出: 1
 */
module.exports = class 位元陣列 {
	/**
	 * @private
	 * @property {string[]} #四位元組
	 * 四位元組對應的二進位字串表。
	 *
	 * @description
	 * 此私有屬性用於存放 `16 進位` 值 (0-F) 所對應的二進位字串表示。
	 * - 每個字串均為 4 位元 (例如：'0000' 對應 0, '1111' 對應 F)。
	 * - 此陣列用於進行進位轉換或處理與位元列表示相關的邏輯。
	 */
	static 四位元組 = ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111',
		'1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111'];
	/**
	 * @private
	 * @property {number} #一頁可記錄的位元數
	 * 每頁能夠記錄的最大位元數量，默認為 24 位元。
	 *
	 * @description
	 * 此私有屬性用於定義每個頁面可以存放的最大位元數量，作為頁面分配與管理的基準。
	 * - 初始化默認值為固定值 24。
	 * - 此值影響所有與分頁相關的操作。
	 */
	#一頁可記錄的位元數 = 24;
	/**
	 * @private
	 * @property {number} #數量
	 * 當前位元陣列中總位元的數量，默認為 0。
	 *
	 * @description
	 * 此私有屬性能記錄實例中目前已初始化的總位元數量，可用於查詢或處理位元計數邏輯。
	 * - 初始化為 0，表示尚未配置任何位元。
	 * - 此屬性在初始化及後續的位元操作中被動態更新。
	 */
	#數量 = 0;

	/**
	 * @private
	 * @property {Array} #頁面
	 * 頁面陣列，用於存放分頁的位元資料。
	 *
	 * @description
	 * 此私有屬性為一個陣列，用於拆分和存放每頁的位元資訊。
	 * - 依照 `#一頁可記錄的位元數` 進行分頁管理，超出限制時自動擴展。
	 * - 初始值為空陣列，表示尚未有任何頁面的位元記錄。
	 *
	 * @example
	 * // 假設一頁可記錄 24 位元：
	 * const 位元資料 = new 位元陣列(48);
	 * console.log(位元資料.#頁面.length); // 預期輸出: 2
	 */
	#頁面 = [];

	/**
	 * 建構一個新的位元陣列實例，根據初始值進行初始化。
	 *
	 * @constructor
	 * @param {string|number|undefined} 初始值 - 用於初始化位元陣列的初始值。
	 *                                     - 若為字串，則視為二進位字串進行解析。
	 *                                     - 若為數值，則初始化對應數量的位元（全為 0）。
	 *                                     - 若未提供初始值，則初始化位元數量為 0。
	 *
	 * @description
	 * 此建構函式根據傳入的 `初始值` 類型來初始化位元陣列：
	 * - 若 `初始值` 是字串，則調用 `解析二進位字串` 方法，以字串的二進位值初始化。
	 * - 若 `初始值` 是數字，則調用私有方法 `#設定位元數量`，初始化指定數量的位元（預設值為 0）。
	 * - 若 `初始值` 未提供或類型無法識別，則默認初始化一個空的位元陣列（位元數量為 0）。
	 *
	 * 此建構函式允許靈活的初始化方式，適合不同的使用場景。
	 *
	 * @example
	 * // 範例 1: 使用二進位字串初始化
	 * const bitArray1 = new 位元陣列("10101");
	 * console.log(bitArray1.數量); // 輸出: 5
	 *
	 * @example
	 * // 範例 2: 使用數值初始化 (位元數量)
	 * const bitArray2 = new 位元陣列(10);
	 * console.log(bitArray2.數量); // 輸出: 10
	 *
	 * @example
	 * // 範例 3: 無初始值
	 * const bitArray3 = new 位元陣列();
	 * console.log(bitArray3.數量); // 輸出: 0
	 */
	constructor (初始值) {
		if (型別.是字串(初始值)) {
			this.解析二進位字串(初始值);
		} else if (型別.是數字(初始值)) {
			this.#設定位元數量(初始值);
		} else {
			this.#設定位元數量(0);
		}
	}

	/**
	 * 取得當前位元陣列的總位元數量。
	 *
	 * @readonly
	 * @returns {number} - 回傳位元的總數量。
	 *
	 * @description
	 * 此屬性為唯讀屬性，用於獲取當前位元陣列所包含的總位元數量。
	 * - 總數量由內部私有屬性 `#數量` 定義與維護。
	 * - 主要應用於瞭解位元陣列的大小，用於後續的位元操作或邏輯判斷。
	 *
	 * @example
	 * // 範例 1: 獲取非空位元陣列的總數量
	 * const array = new 位元陣列(100); // 假設初始化 100 位元
	 * console.log(array.數量); // 輸出: 100
	 *
	 * @example
	 * // 範例 2: 獲取空位元陣列的總數量
	 * const emptyArray = new 位元陣列(0); // 假設初始化為空
	 * console.log(emptyArray.數量); // 輸出: 0
	 */
	get 數量 () {
		return this.#數量;
	}

	/**
	 * 取得當前位元陣列的頁面數量。
	 *
	 * @readonly
	 * @returns {number} - 回傳頁面數量。
	 *
	 * @description
	 * 此屬性為唯讀屬性，用於取得當前位元陣列中的總頁數。
	 * - 頁面數量會根據內部私有屬性 `#頁面` 的長度自動計算。
	 * - 頁面數從 0 開始累計，且只讀，無法直接修改。
	 *
	 * @example
	 * // 範例 1: 獲取頁面數量
	 * const array = new 位元陣列();
	 * console.log(array.頁面數量); // 假設內部有 5 頁，輸出: 5
	 *
	 * @example
	 * // 範例 2: 當無任何頁面存在
	 * const emptyArray = new 位元陣列();
	 * console.log(emptyArray.頁面數量); // 假設內部無頁面，輸出: 0
	 */
	get 頁面數量 () {
		return this.#頁面.length;
	}

	/**
	 * 根據位元編號計算所在的頁面編號。
	 *
	 * @private
	 * @param {number} 位元編號 - 要計算的位元編號，需為非負整數。
	 * @returns {number} - 該位元編號對應的頁面編號，從 0 開始。
	 *
	 * @description
	 * 此方法根據每頁可記錄的位元數 (`this.#一頁可記錄的位元數`)，透過公式計算指定位元編號所屬的頁面編號：
	 * `Math.floor(位元編號 / 每頁可紀錄位元數)`。
	 *
	 * - 頁面編號從 0 開始，對應的是位元的歸屬位置。
	 * - 此方法不處理傳入位元編號的有效性，需保證傳入值合法（非負數，且位於有效範圍內）。
	 *
	 * @example
	 * // 範例 1: 位元編號在第一頁
	 * const array = new 位元陣列();
	 * const page1 = array.#取得頁面編號(15); // 假設每頁可記錄 32 位元
	 * console.log(page1); // 輸出: 0
	 *
	 * @example
	 * // 範例 2: 位元編號在第二頁
	 * const page2 = array.#取得頁面編號(45); // 假設每頁可記錄 32 位元
	 * console.log(page2); // 輸出: 1
	 *
	 * @example
	 * // 範例 3: 位元編號為頁面邊界
	 * const page3 = array.#取得頁面編號(64); // 假設每頁可記錄 32 位元
	 * console.log(page3); // 輸出: 2
	 */
	#取得頁面編號 (位元編號) {
		return Math.floor(位元編號 / this.#一頁可記錄的位元數);
	}

	/**
	 * 執行位元陣列之間的邏輯運算。
	 *
	 * @private
	 * @param {位元陣列} 另一個向量 - 用於進行邏輯運算的另一個位元陣列，該陣列的位元數量必須與當前陣列相同。
	 * @param {string} 運算符 - 指定的邏輯運算符，可為以下值之一：
	 *                          - `'and'`：執行位元的 AND（且）運算。
	 *                          - `'or'`：執行位元的 OR（或）運算。
	 *                          - `'xor'`：執行位元的 XOR（異或）運算。
	 * @returns {位元陣列} - 返回邏輯運算的結果，為新的位元陣列。
	 * @throws {參數錯誤} - 如果傳入的位元陣列 `另一個向量` 的位元數量與當前位元陣列不同，則拋出此錯誤。
	 *
	 * @description
	 * 該方法接受另一個位元陣列以及指定的邏輯運算符，並對兩者進行逐位元的運算操作。運算結果將存放於一個新的位元陣列中，並作為返回值。
	 * - 在進行運算之前，方法會驗證兩個位元陣列的位元數量是否一致，若不一致則拋出錯誤。
	 * - 支援的邏輯運算包括 AND（且）、OR（或）和 XOR（異或）。
	 * - 每個邏輯運算通過高效的二元運算符實現，並使用 `#頁面` 陣列進行逐頁處理。
	 *
	 * @example
	 * // 範例：進行 AND 運算
	 * const array1 = new 位元陣列(10); // 位元數為 10
	 * const array2 = new 位元陣列(10);
	 * const result = array1.and(array2); // 進行 AND 運算，返回新位元陣列
	 *
	 * @example
	 * // 範例：處理位元數不同的情況
	 * const array1 = new 位元陣列(10);
	 * const array2 = new 位元陣列(8);
	 * try {
	 *   const result = array1.and(array2); // 位元數不同時拋出參數錯誤
	 * } catch (error) {
	 *   console.error(error.message); // 輸出錯誤信息
	 * }
	 */
	#執行邏輯運算 (另一個向量, 運算符) {
		this.#驗證(另一個向量.數量 === this.數量, 參數錯誤, '位元數不同無法進行運算');

		const 二元運算 = {
			'and': (a, b) => a & b,
			'or': (a, b) => a | b,
			'xor': (a, b) => a ^ b
		}[運算符];

		const 結果 = new 位元陣列(this.數量);
		結果.#頁面 = this.#頁面.map((x, index) => 二元運算(x, 另一個向量.#頁面[index]));
		return 結果;
	}

	/**
	 * 驗證給定的字串是否僅包含 '0' 和 '1'。
	 *
	 * @private
	 * @param {string} 字串 - 要驗證的二進位字串。
	 * @throws {二進位字串內容錯誤} - 當字串包含非 '0' 或 '1' 的字元時，拋出此錯誤。
	 *
	 * @description
	 * 此方法會逐一檢查給定字串的每個字元，以確保字串僅包含合法的二進位字元 ('0' 和 '1')：
	 * - 如果字串為空值或未提供，方法將直接返回，不進行任何檢查。
	 * - 如果發現非二進位字元 ('0' 或 '1' 以外)，則立即拋出 `二進位字串內容錯誤`。
	 *
	 * 此方法的主要用途是保證提供的二進位字串符合格式要求，避免後續處理時出現數據錯誤。
	 *
	 * @example
	 * // 範例 1: 驗證合法字串
	 * const array = new 位元陣列();
	 * array.#確保二進位字串只有0和1的字元("10101"); // 無錯誤
	 *
	 * @example
	 * // 範例 2: 驗證包含非法字元的字串
	 * try {
	 *   array.#確保二進位字串只有0和1的字元("10201");
	 * } catch (error) {
	 *   console.error(error.message); // 輸出: "二進位字串內容錯誤"
	 * }
	 *
	 * @example
	 * // 範例 3: 空值處理
	 * array.#確保二進位字串只有0和1的字元(""); // 無錯誤
	 */
	#確保二進位字串只有0和1的字元 (字串) {
		if (!字串) {
			return;
		}
		for (let i = 0; i < 字串.length; i++) {
			if (字串[i] !== '0' && 字串[i] !== '1') {
				throw new 二進位字串內容錯誤;
			}
		}
	}

	/**
	 * 驗證位元編號是否在有效範圍內。
	 *
	 * @private
	 * @param {number} 位元編號 - 要驗證的位元編號，必須為數值且位於有效範圍內。
	 * @throws {型別錯誤} - 如果位元編號不是數值，則拋出型別錯誤。
	 * @throws {索引超出範圍錯誤} - 如果位元編號小於 0 或超出位元陣列的範圍，則拋出索引超出範圍的錯誤。
	 *
	 * @description
	 * 此方法用於驗證給定的位元編號是否合法：
	 * - 位元編號必須是數值類型，否則拋出型別錯誤。
	 * - 位元編號的值必須在範圍 `[0, this.#數量 - 1]` 內，否則拋出索引超出範圍的錯誤。
	 *
	 * 此方法主要應用於內部操作，用來保證位元操作的安全性和數據完整性。
	 *
	 * @example
	 * // 範例 1: 驗證有效位元編號
	 * const array = new 位元陣列(10);
	 * array.#確定位元編號在範圍內(5); // 無錯誤
	 *
	 * @example
	 * // 範例 2: 非數值編號
	 * try {
	 *   array.#確定位元編號在範圍內("文字");
	 * } catch (error) {
	 *   console.error(error.message); // 輸出: "位元編號必須是數值"
	 * }
	 *
	 * @example
	 * // 範例 3: 編號超出範圍
	 * try {
	 *   array.#確定位元編號在範圍內(15);
	 * } catch (error) {
	 *   console.error(error.message); // 輸出: "位元編號必須在(0,9)之間。"
	 * }
	 */
	#確定位元編號在範圍內 (位元編號) {
		this.#驗證(
			型別.是數字(位元編號),
			型別錯誤,
			錯誤訊息.位元陣列.位元編號必須是數值
		);

		this.#驗證(
			位元編號 >= 0 && 位元編號 < this.#數量,
			索引超出範圍錯誤,
			`位元編號必須在(0,${this.#數量 - 1})之間。`
		);
	}

	/**
	 * 計算指定位元數量所需的頁面數量。
	 *
	 * @private
	 * @param {number} 位元數量 - 需要存儲的位元總數，必須為非負數。
	 * @returns {number} - 回傳所需的頁面數量。
	 *
	 * @description
	 * 此方法根據每頁可儲存的位元數量計算出需要的頁面數量。使用公式將位元數量平均分配到頁面上：
	 * `Math.floor((位元數量 + 每頁可紀錄位元數 - 1) / 每頁可紀錄位元數)`。
	 * - 預先加上 `每頁可紀錄位元數 - 1` 是為了實現向上取整的效果。
	 * - 因此，無論位元數量是否能整除每頁可紀錄位元數，會自動計算額外的頁面來存儲餘數位元。
	 *
	 * @example
	 * // 範例 1: 精確計算頁面數
	 * const array = new 位元陣列();
	 * const pages = array.#計算需要的頁面數量(100); // 假設每頁紀錄 32 位元
	 * console.log(pages); // 輸出: 4
	 *
	 * @example
	 * // 範例 2: 當位元數量為零
	 * const pages = array.#計算需要的頁面數量(0);
	 * console.log(pages); // 輸出: 0
	 */
	#計算需要的頁面數量 (位元數量) {
		return Math.floor((位元數量 + this.#一頁可記錄的位元數 - 1) / this.#一頁可記錄的位元數);
	}

	/**
	 * 設定位元陣列的位元數量，並根據新位元數初始化頁面數據。
	 *
	 * @private
	 * @param {number} 新數量 - 新的位元數量，必須是大於或等於零的數值。
	 * @throws {型別錯誤} - 如果 `新數量` 不是數值或小於零，則會拋出此錯誤。
	 *
	 * @description
	 * 當前位元數量會被重置為提供的 `新數量`。內部頁面數據的大小會根據位元數量的需求重新計算並初始化為預設值（填充為 0）。
	 *
	 * @example
	 * // 範例 1: 正確設定位元數量
	 * const array = new 位元陣列();
	 * array.#設定位元數量(16); // 設定位元數量為 16
	 *
	 * @example
	 * // 範例 2: 錯誤參數處理
	 * const array = new 位元陣列();
	 * try {
	 *   array.#設定位元數量(-5); // 傳入無效參數，將拋出型別錯誤
	 * } catch (error) {
	 *   console.error('錯誤:', error.message); // 錯誤處理
	 * }
	 */
	#設定位元數量 (新數量) {
		this.#驗證(
			型別.是數字(新數量) && 新數量 >= 0,
			型別錯誤,
			錯誤訊息.位元陣列.位元數必須是大於零的數值
		);
		this.#頁面.length = this.#計算需要的頁面數量(新數量);
		this.#頁面.fill(0);
		this.#數量 = 新數量;
	}

	#驗證 (條件, 錯誤類別, 錯誤訊息) {
		if (!條件) {
			throw new 錯誤類別(錯誤訊息);
		}
	}

	/**
	 * 與傳入的位元陣列進行 AND（且）運算，並返回一個新的位元陣列。
	 *
	 * @param {位元陣列} 另一個陣列 - 欲進行 AND 運算的位元陣列，其位元數量必須與當前位元陣列相同。
	 * @returns {位元陣列} - 一個新的位元陣列，包含每個位元進行 AND 運算後的結果。
	 * @throws {參數錯誤} - 如果兩個位元陣列的位元數量不同，則會拋出此錯誤。
	 *
	 * @example
	 * // 範例 1: 正確使用 AND 運算
	 * const array1 = new 位元陣列(8); // 建立一個長度為 8 的位元陣列
	 * const array2 = new 位元陣列(8); // 建立另一個長度為 8 的位元陣列
	 * const result = array1.and(array2); // 與第二個陣列進行 AND 運算，返回新的位元陣列
	 *
	 * @example
	 * // 範例 2: 長度不一致的例外處理
	 * const array1 = new 位元陣列(8); // 長度為 8 的位元陣列
	 * const array2 = new 位元陣列(16); // 長度為 16 的位元陣列
	 * try {
	 *   const result = array1.and(array2); // 長度不符，將拋出參數錯誤
	 * } catch (error) {
	 *   console.error('錯誤:', error.message); // 處理錯誤訊息
	 * }
	 */
	and (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'and');
	}

	/**
	 * 對當前位元陣列的每個位元進行 NOT（反轉）運算，並返回一個新的位元陣列。
	 *
	 * @returns {位元陣列} - 包含每個位元進行 NOT 運算後結果的新的位元陣列。
	 *
	 * @example
	 * // 範例 1: 對位元陣列進行 NOT 運算
	 * const array = new 位元陣列(8); // 建立一個長度為 8 的位元陣列
	 * const result = array.not(); // 對陣列進行 NOT 運算，返回反轉結果
	 */
	not () {
		let 回傳結果 = new 位元陣列(this.數量);
		回傳結果.#頁面 = this.#頁面.map(x => ~x);
		return 回傳結果;
	}

	/**
	 * 與傳入的位元陣列進行 OR（或）運算，並返回一個新的位元陣列。
	 *
	 * @param {位元陣列} 另一個陣列 - 欲進行 OR 運算的位元陣列，其位元數量必須與當前位元陣列相同。
	 * @returns {位元陣列} - 包含進行 OR 運算後結果的新的位元陣列。
	 * @throws {參數錯誤} - 如果兩個位元陣列的位元數量不同，則會拋出此錯誤。
	 *
	 * @example
	 * // 範例 1: 正確使用
	 * const array1 = new 位元陣列(8); // 建立一個長度為 8 的位元陣列
	 * const array2 = new 位元陣列(8); // 建立另一個長度為 8 的位元陣列
	 * const result = array1.or(array2); // 與第二個位元陣列進行 OR 運算，返回結果
	 *
	 * @example
	 * // 範例 2: 長度不一致
	 * const array1 = new 位元陣列(8); // 建立一個長度為 8 的位元陣列
	 * const array2 = new 位元陣列(16); // 建立一個長度為 16 的位元陣列
	 * try {
	 *   const result = array1.or(array2); // 長度不符，拋出參數錯誤
	 * } catch (error) {
	 *   console.error('錯誤:', error.message); // 處理錯誤訊息
	 * }
	 */
	or (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'or');
	}

	/**
	 * 與傳入的位元陣列進行 XOR（異或）運算，並返回一個新的位元陣列結果。
	 *
	 * @param {位元陣列} 另一個陣列 - 欲進行 XOR 運算的位元陣列，其位元長度必須與當前位元陣列相同。
	 * @returns {位元陣列} - 包含 XOR 運算結果的新的位元陣列。
	 * @throws {參數錯誤} - 當傳入的位元陣列的位元長度與當前位元陣列不一致時會拋出此錯誤。
	 *
	 * @example
	 * const array1 = new 位元陣列(8); // 建立 8 位元的位元陣列
	 * const array2 = new 位元陣列(8); // 再建立一個長度相同的位元陣列
	 * const result = array1.xor(array2); // 與 array2 進行 XOR 運算，返回新的位元陣列
	 *
	 * @example
	 * const array1 = new 位元陣列(8);
	 * const array2 = new 位元陣列(16);
	 * try {
	 *   const result = array1.xor(array2); // 由於長度不同，拋出參數錯誤
	 * } catch (error) {
	 *   console.error(error.message);
	 * }
	 */
	xor (另一個陣列) {
		return this.#執行邏輯運算(另一個陣列, 'xor');
	}

	/**
	 * 查詢指定位置的位元是否為 1。
	 *
	 * @param {number} 位元編號 - 位元的編號，必須為大於等於 0 且小於位元總數的整數。
	 * @returns {boolean} - 如果指定位置的位元為 1，返回 `true`；否則返回 `false`。
	 * @throws {型別錯誤} - 當傳入的位元編號不是數字時拋出此錯誤。
	 * @throws {索引超出範圍錯誤} - 當位元編號超出合法範圍時拋出此錯誤。
	 *
	 * @example
	 * const 位元陣列 = new 位元陣列(16);  // 建立具有 16 個位元的位元陣列
	 * 位元陣列.狀態(0); // 假設第 0 位元為 0，則返回 `false`
	 * 位元陣列.狀態(15); // 假設第 15 位元為 1，則返回 `true`
	 *
	 * @example
	 * try {
	 *   const 位元陣列 = new 位元陣列(8);
	 *   位元陣列.狀態(-1);  // 無效的位元編號，拋出 RangeError
	 * } catch (error) {
	 *   console.error(error.message);
	 * }
	 */
	狀態 (位元編號) {
		// 確保位元編號在合法範圍內
		this.#確定位元編號在範圍內(位元編號);

		// 計算頁面索引與位元遮罩
		const 頁面索引 = this.#取得頁面編號(位元編號);
		const 位元遮罩 = 1 << (位元編號 % this.#一頁可記錄的位元數);

		// 取得該位元的狀態並返回結果
		return (this.#頁面[頁面索引] & 位元遮罩) !== 0;
	}

	/**
	 * 複製當前的位元陣列，並產生新的位元陣列實例。
	 *
	 * @returns {位元陣列} - 新的位元陣列，內容與當前位元陣列相同。
	 */
	複製 () {
		const 新位元陣列 = new 位元陣列(this.數量);
		新位元陣列.#頁面 = this.#頁面.slice(); // 高效拷貝陣列
		return 新位元陣列;
	}

	/**
	 * 解析一段二進位字串，並將其轉換為位元陣列的值。
	 * 字串中的所有空白字元會被自動移除。若傳入的字串中包含非 `0` 與 `1` 的字元，則會拋出例外。
	 *
	 * @param {string} 二進位字串 - 只包含二進位的數字字串，可以帶有空白字元（不影響解析）。
	 * @returns {位元陣列} - 返回包含所解析結果的當前位元陣列，支援鏈式調用。
	 *
	 * @throws {Error} 如果字串中包含非 `0` 與 `1` 的字符，則拋出錯誤。
	 *
	 * @example
	 * // 建立一個空的位元陣列並解析二進位字串
	 * const 位元陣列 = new 位元陣列(0);
	 * 位元陣列.解析二進位字串('1010 1010'); // 結果為位元陣列 [0b10101010]
	 *
	 * @example
	 * // 當字串非法時將拋出錯誤
	 * const 位元陣列 = new 位元陣列(0);
	 * 位元陣列.解析二進位字串('1021'); // 拋出例外：字串中包含無效字符。
	 */
	解析二進位字串 (二進位字串) {
		const 移除空白之後的二進位字串 = 字串工具.移除空白字元(二進位字串);
		this.#確保二進位字串只有0和1的字元(移除空白之後的二進位字串);
		let 結束位置 = 移除空白之後的二進位字串.length;
		let 起始位置 = 結束位置 - Math.min(this.#一頁可記錄的位元數, 移除空白之後的二進位字串.length);
		this.#設定位元數量(移除空白之後的二進位字串.length);
		let 頁面編號 = 0;
		while (頁面編號 < this.#頁面.length) {
			let part = 移除空白之後的二進位字串.substring(起始位置, 結束位置);
			this.#頁面[頁面編號] = parseInt(part, 2);
			結束位置 -= this.#一頁可記錄的位元數;
			起始位置 -= this.#一頁可記錄的位元數;
			頁面編號++;
		}
		return this;
	}

	/**
	 * 將所有位元的狀態設定為 `true` 或 `false`。
	 *
	 * @param {boolean} 狀態 - `true` 表示所有位元設為 1，`false` 表示設為 0。
	 * @returns {位元陣列} - 返回當前位元陣列以支援鏈式調用。
	 *
	 * @example
	 * const 位元陣列 = new 位元陣列(25);
	 * 位元陣列.設定全部狀態(true); // 結果：1111111111111111111111111
	 */
	設定全部狀態 (狀態) {
		const 填充值 = 狀態 ? 0xFFFFFF : 0;

		// 填充每一頁為設定的值
		this.#頁面.fill(填充值);

		return this; // 支援鏈式調用
	}

	/**
	 * 設定位元編號的狀態。
	 *
	 * @param {number} 位元編號 - 位元編號，必須 >= 0 且小於位元數。
	 * @param {boolean} 狀態 - `true` 表示設為 1，`false` 表示設為 0。
	 * @returns {位元陣列} - 返回當前位元陣列以支援鏈式調用。
	 *
	 * @example
	 * const 位元陣列 = new 位元陣列(24);
	 * 位元陣列.設定狀態(1, true);
	 * 位元陣列.設定狀態(2, false);
	 */
	設定狀態 (位元編號, 狀態) {
		// 驗證位元編號是否在合法範圍內
		this.#確定位元編號在範圍內(位元編號);

		// 計算分頁編號與對應的位元遮罩
		const 分頁編號 = this.#取得頁面編號(位元編號);
		const 位元遮罩 = 1 << (位元編號 % this.#一頁可記錄的位元數);

		// 根據狀態設置位元的值
		this.#頁面[分頁編號] = 狀態
			? this.#頁面[分頁編號] | 位元遮罩
			: this.#頁面[分頁編號] & ~位元遮罩;

		return this; // 支援鏈式調用
	}

	/**
	 * 將整個位元陣列以 01 的字串表示。
	 *
	 * @returns {string} - 表示位元陣列的 01 字串。
	 *
	 * @example
	 * const 位元陣列 = new 位元陣列();
	 * console.log(位元陣列.轉為二進位字串());
	 */
	轉為二進位字串 () {
		const 四位元組的數量 = this.#一頁可記錄的位元數 / 4;
		const 結果 = this.#頁面.flatMap(x =>
			Array.from({ length: 四位元組的數量 }, (_, i) =>
				位元陣列.四位元組[(x >> (i * 4)) & 0x0000000F]
			)
		);
		return 結果.reverse().join('').slice(-this.#數量);
	}

};
